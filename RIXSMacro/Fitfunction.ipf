#pragma rtGlobals=1		// Use modern global access method.Function init_FitFN_text(PeakFns,bkgFns,coefFns)	Wave /T PeakFns	Wave /T bkgFns	Wave /T coefFns	//The foolowing are the original list of background type. Commented out by W. S. Lee 01/26 2023//	PeakFns[][0]={{"Anti-Lorentz","Gauss","Doniach-Sunjic","Fermi-liquid","marginal-FL","empirical-FL","Dyne-Fn","Sym_Fn","Sym_BCS"}}//	PeakFns[][1]={{"3","3","4","6","6","5","3","4","4","2"}}//	PeakFns[][2]={{"position","position",	"position","position","position","position","Gap","Gap","Gap"}}//	PeakFns[][3]={{"intensity","intensity","intensity","intensity","intensity","intensity","intensity","intensity","intensity"}}//	PeakFns[][4]={{"FWHM","FWHM","FWHM","impurity","impurity","a0","Scatter1","Scatter1","Scatter1"}}//	PeakFns[][5]={{"","","asymmetry","beta","lambda","b_x_w","","Scatter0","Scatter0"}}//	PeakFns[][6]={{"","","","EF","EF","c_x_w2","","","",""}}//	PeakFns[][7]={{"","","","T","T","","","","",""}}	//	bkgFns[][0]={{	"constant","linear","2. order polynom","3. order polynom","exponential","polynom-FD","Shirley BG","bkg_Lorentz","bkg_Gauss"}}//	bkgFns[][1]={{"1","3","4","5","4","5","3","3","3"}}//	bkgFns[][2]={{	"constant","offset","offset","offset","offset","offset","offset","position","position"}}//	bkgFns[][3]={{	"",	"constant","0. order","0. order","constant","constant","constant","intensity","intensity"}}//	bkgFns[][4]={{	"",	"slope","1.order",	"1.order","intensity","intensity","intensity","FWHM","FWHM"}}//	bkgFns[][5]={{	"","","2.order","2.order","decay","EF","","",""}}//	bkgFns[][6]={{"","","","3.order","","Tem","","",""}}		PeakFns[][0]={{"Anti-Lorentz","Gauss","Anti-Gauss","Damped_HO", "DHO_T","Lorentiz","Voigt"}}	PeakFns[][1]={{"4","3","4","4","5","3","4"}}	PeakFns[][2]={{"modePos","position","modPos","modePos","modePos","position","position"}}	PeakFns[][3]={{"intensity","intensity","intensity","intensity","intensity","intensity","intensity"}}	PeakFns[][4]={{"FWHM","FWHM","FWHM","FWHM","FWHM","FWHM","FWHM"}}	PeakFns[][5]={{"zero","","zero","zero","zero","","shape"}}	PeakFns[][6]={{"","","","","Temp","",""}}	PeakFns[][7]={{"","","","","","",""}}		bkgFns[][0]={{	"constant","linear","step","2. order polynom","3. order polynom"}}	bkgFns[][1]={{"1","3","3","4","5"}}	bkgFns[][2]={{	"constant","offset","height","offset","offset"}}	bkgFns[][3]={{	"",	"constant","center","0. order","0. order"}}	bkgFns[][4]={{	"",	"slope","width","1.order","1.order"}}	bkgFns[][5]={{	"","","","2.order","2.order"}}	bkgFns[][6]={{  "","","","","3.order"}}		// For some reason, I have to keep the "Convolve" in the second place in orfer to make it work... W. S. Lee 01/26/2023	//coefFns[][0]={{"xFermi","Convolve","Offset","symbkg"}}	coefFns[][0]={{"","Convolve","",""}}	coefFns[][1]={{"","1","",""}}	coefFns[][2]={{"","FWHM","",""}}	//coefFns[][3]={{"","","",""}}	//coefFns[][4]={{"","","",""}}		EndThreadSafe Function composed_FitFn(coef,x,w_trace,FitPar_Fnnum,FitPar_parnum,Fnnum_single,gv_symbkgflag,gv_absbkgflag)	Wave coef	Variable x			Wave w_trace//=DFR_common:w_trace	Wave FitPar_Fnnum//=DFR_panel:FitPar_Fnnum	Wave FitPar_parnum//=DFR_panel:FitPar_parnum	variable  gv_symbkgflag//=DFR_panel:gv_symbkgflag       Variable gv_absbkgflag//=DFR_panel:gv_absbkgflag           Variable Fnnum_single		Variable kB=8.617385e-5 			Variable peak=0,bkg=0,offset=0,fermi=1	Variable fnnum	Variable index,parindex=-1	Variable FackX,bkgtemp			index=0 //search symbkg	do		if (index>=numpnts(FitPar_Fnnum))			break		endif		fnnum= FitPar_Fnnum[index]		if (fnnum==4)			Variable Tbkg=coef[parindex+1]		endif		parindex+=FitPar_parnum[index]		index+=1	while (index<numpnts(FitPar_Fnnum))	parindex=-1		    			    			index=0		//NVAR gv_Fermiflag=DFR_panel:gv_Fermiflag    // NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	//NVAR gv_Offsetflag=DFR_panel:gv_Offsetflag   	do				if (index>=numpnts(FitPar_Fnnum))			break		endif		fnnum= FitPar_Fnnum[index]				if (Fnnum_single>=0)			if (index!=Fnnum_single)				parindex= parindex+FitPar_parnum[index]				index+=1				continue			endif		endif					if (fnnum>=400)//bkg			fnnum-=400						switch(fnnum)				case 0:		//Constant Background					bkgtemp= coef[parindex+1]					break				case 1:		//Linear Background					bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1])					break						case 2:		//Step Function Background					// Step Function Background with zero energy to be an additional fit parameter					// Modified by J. R. Li					//coef[parameter+1]:height					//coef[parameter+2]:center					//coef[parameter+3]:FWHM					bkgtemp= ((x-coef[parindex+2])>=0)*coef[parindex+1]*(1/(1+exp(-(x- coef[parindex+2])/coef[parindex+3]))-0.5)					break							//				case 2:		//Lorentian background//					bkgtemp = (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)//				break	//				case 3:		//Gaussian background//				variable aux0 = 2*sqrt(ln(2))//					bkgtemp = coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) //					break			endswitch						bkg+=bkgtemp	//			The following is considered a symmetrize bckground. I don't think it is useful for RIXS. So I comment out. W. S. Lee 01/26 2023			//			FackX=x//			//			if (gv_symbkgflag)//				x=-x//				switch(fnnum)//				case 0:		//					bkgtemp= coef[parindex+1]//					break//				case 1:		//					bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1])//					break						//				case 2:		//					bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1])//					break//				case 3:		//					bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1]) + coef[parindex+5]*(x-coef[parindex+1])*(x-coef[parindex+1])*(x-coef[parindex+1])//					break			//				case 4:			//					bkgtemp= coef[parindex+2] + coef[parindex+3]* exp(-(x-coef[parindex+1])/coef[parindex+4])//					break//				case 5://					bkgtemp= (coef[parindex+2]+coef[parindex+3]*(x-coef[parindex+1])^2) / (exp( (x-coef[parindex+4])/abs(coef[parindex+5]*KB))+1)//					break//				case 6://					bkgtemp= coef[parindex+3] * area(w_trace, x,coef[parindex+1])+coef[parindex+2]//					break//				case 7://					bkgtemp = (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)//					break	//				case 8://					variable aux0 = 2*sqrt(ln(2))//					bkgtemp = coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) //					break//				endswitch//					//				if (gv_absbkgflag)//					bkgtemp=(bkgtemp<0)?(0):bkgtemp//				endif//				//				bkg+=bkgtemp*1/(exp((x) / (kB*Tbkg))+1.0 )//				//			endif//			//			x=FackX			//			switch(fnnum)//			case 0:		//				bkgtemp= coef[parindex+1]//				break//			case 1:		//				bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1])//				break						//			case 2:		//				bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1])//				break//			case 3:		//				bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1]) + coef[parindex+5]*(x-coef[parindex+1])*(x-coef[parindex+1])*(x-coef[parindex+1])//				break			//			case 4:			//				bkgtemp= coef[parindex+2] + coef[parindex+3]* exp(-(x-coef[parindex+1])/coef[parindex+4])//				break//			case 5://				bkgtemp= (coef[parindex+2]+coef[parindex+3]*(x-coef[parindex+1])^2) / (exp( (x-coef[parindex+4])/abs(coef[parindex+5]*KB))+1)//				break//			case 6://				bkgtemp= coef[parindex+3] * area(w_trace, x,coef[parindex+1])+coef[parindex+2]//				break//			case 7://				bkgtemp = (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)//				break	//			case 8://				 aux0 = 2*sqrt(ln(2))//				bkgtemp = coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) //				break//			endswitch//			//			if (gv_absbkgflag)//				bkgtemp=(bkgtemp<0)?(0):bkgtemp//			endif//				//			if (gv_symbkgflag)//				bkg+=bkgtemp*1/(exp((x) / (kB*Tbkg))+1.0 )//			else//				bkg+=bkgtemp//			endif					elseif (fnnum>=200)//Peak			fnnum-=200						switch(fnnum)				case 0:						// Lorentzian				//peak += (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)								// Anti-Lorentzian								// Modified by W. S. Lee				// Change it to an Anti-Lorentizan function with only the energy losss side. Note : The sign was retrofited such that the energy loss is negative in energy and the energy gain side of the spectrum is set to zero.				// Modified by Haiyu Lu				// Change the sign such that the energy loss is positive in energy				//peak += abs((x>=0)*((coef[parindex+2]/pi*coef[parindex+3]/2) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4) - (coef[parindex+2]/pi*coef[parindex+3]/2) / ((x+coef[parindex+1])^2+coef[parindex+3]^2/4)))								// Anti-Lorentzian	 with zero energy to be an additional fit parameter				// Modified by W. S. Lee				//coef[parameter+1]:Mode Energy relative to the zero energy				//coef[parameter+2]:intensity				//coef[parameter+3]:FWHM				//coef[parameter+4]:zero energy. Usually need to used in constrained fit with the elastic peak position.				variable pre_F = (coef[parindex+2]/pi*coef[parindex+3]/2)				//peak += abs(((x-coef[parindex+4])>=0)*((coef[parindex+2]/pi*coef[parindex+3]/2) / ((x-coef[parindex+4]-coef[parindex+1])^2+coef[parindex+3]^2/4) - (coef[parindex+2]/pi*coef[parindex+3]/2) / ((x-coef[parindex+4]+coef[parindex+1])^2+coef[parindex+3]^2/4)))				peak += abs(((x-coef[parindex+4])>=0)*( pre_F / ((x-coef[parindex+4]-coef[parindex+1])^2+coef[parindex+3]^2/4) - pre_F / ((x-coef[parindex+4]+coef[parindex+1])^2+coef[parindex+3]^2/4)))				break										case 1:						// Gaussian										variable aux0 = 2*sqrt(ln(2))				peak += coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) 				break					case 2:					// Doniach-Sunjic				// w0: position				// w1: intensity				// w2: gamma							// w3: alpha				//variable ds0 =coef[parindex+2]*cos(pi*coef[parindex+4]/2+(1-coef[parindex+4])*atan((x-coef[parindex+1])/coef[parindex+3])) 	// nominator				//variable ds1 = ((x-coef[parindex+1])^2+coef[parindex+3]^2)^((1-coef[parindex+4])/2)									// denominator				//peak += ds0/ds1								//Anti-Gaussian with respective to a zero energy, added by W. S. Lee April 10th, 2023				variable aux1 = 2*sqrt(ln(2))				peak += abs(((x-coef[parindex+4])>=0)*coef[parindex+2]* (exp(-((x-coef[parindex+4]-coef[parindex+1])/(coef[parindex+3]/aux1))^2) - exp(-((x-coef[parindex+4]+coef[parindex+1])/(coef[parindex+3]/aux1))^2)))												break			case 3:				//Damped Harmonic Oscillator				//Modified by W. S. Lee 02/14 2023, add zero energy as additional parameter. 								//peak += abs((x>=0)*((x*coef[parindex+2]/pi*coef[parindex+3]/2) / ((x^2-coef[parindex+1]^2)^2+4*x^2*coef[parindex+3]^2/4))) // original								peak += abs(((x-coef[parindex+4])>=0)*(((x-coef[parindex+4])*coef[parindex+2]/pi*coef[parindex+3]/2) / (((x-coef[parindex+4])^2-coef[parindex+1]^2)^2+4*(x-coef[parindex+4])^2*coef[parindex+3]^2/4))) //energy loss side of spectral function				break							case 4:				//Damped Harmonic Oscillator on the Energy Gain side with Temperature 				//Added by W. S. Lee 02/18 2023. 								//peak += abs((x>=0)*((x*coef[parindex+2]/pi*coef[parindex+3]/2) / ((x^2-coef[parindex+1]^2)^2+4*x^2*coef[parindex+3]^2/4))) // original				variable bkT = (x-coef[parindex+4])/ (coef[parindex+5] * 8.617e-5)				variable preF = 1 / (1-exp(-1*bkT))				peak += preF*(((x-coef[parindex+4])*coef[parindex+2]/pi*coef[parindex+3]/2) / (((x-coef[parindex+4])^2-coef[parindex+1]^2)^2+4*(x-coef[parindex+4])^2*coef[parindex+3]^2/4)) //energy loss side of spectral function				break							case 5:			// Lorentzian				peak += (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)				break						case 6: //Add Voigt function by W.S. Lee 06/16/2023							make /O/N=5 coef_Voigt				wave coef_Voigt = coef_Voigt // the parameter wave for the Igor Pro built in Voigt funtion				coef_Voigt[0] = 0 //this is the DC offset in the Igor Pro built in Voigt funtion. we dont need it here				coef_Voigt[1] = coef[parindex+2] // area i.e intensity				coef_Voigt[2] = coef[parindex+1] //peak position				coef_Voigt[3] = coef[parindex+3] //FWHM of Gaussian component				coef_Voigt[4] = coef[parindex+4]	// Ratio of Lorenztian component width to the Gaussian component width. For w[4]=0, the peak shape is purely Gaussian, as w[4] → ∞, the peak shape become purely Lorenztian. A value of 1 results in Gaussian and Lorenztian components of equal width.				peak += VoigtPeak(coef_Voigt,x)				break//			case 3://				// Fermi-liquid//				// requires Fermi-funciton parameters//				//checked correct 201801 sdc//				aux0 = coef[parindex+3] +coef[parindex+4]* ((x-coef[parindex+5])^2 + (pi*kB*coef[parindex+6])^2)	// self energy with impurity scattering//				//peak += (w[par0+1]*aux0^2/pi) / ((x-w[par0])^2+aux0^2)	// corrected 06-08-04//				peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2)//				break//			case 4://				// marginal Fermi-liquid//				// requires Fermi-funciton parameters//				//checked correct 201801 sdc//				aux0 = coef[parindex+3] + coef[parindex+4]* pi*0.5*sqrt((x-coef[parindex+5])^2 + (pi*kB*coef[parindex+6])^2) //corrected 2012-12-16		// self energy with impurity scattering//				peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2)//				break//			case 5://				// "empirical FL"//				aux0 = coef[parindex+3] + coef[parindex+4]*x + coef[parindex+5]*x*x//				peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2/4)//				break//	       case 6://	           //dyne function//	           variable /C E=cmplx(x,0)//				variable /C Gap=cmplx(coef[parindex+1],0)//				variable /C GGamma=cmplx(0,coef[parindex+3])//				peak += abs(coef[parindex+2]*real((E-GGamma)/(sqrt((E-GGamma)*(E-GGamma)-Gap*Gap))))//	           break//	       case 7://	           // SC spectra function//	           if (x==0)//  				Variable Aw=1/pi/coef[parindex+3]//				else//				Variable SelfEIm=-coef[parindex+3]-coef[parindex+1]^2*coef[parindex+4]/(x^2+coef[parindex+4]^2)//				Variable SelfERe=coef[parindex+1]^2*x/(x^2+coef[parindex+4]^2)//				 Aw=1/pi*SelfEIm/((x-SelfERe)*(x-SelfERe)+SelfEIm*SelfEIm)//				endif//				peak+=-coef[parindex+2]*Aw//	          //make /o/n=4 symEDCcof//              // symEDCcof=w[par0+p]//              // peak += CalsymEDCfit(symEDCcof,x)//               break//          // case 8:  //               // BCS spectra function  //           //    Aw=0.5/pi*(coef[parindex+3]/((x-abs(coef[parindex+1]))^2+coef[parindex+3]^2)+coef[parindex+3]/((x+abs(coef[parindex+1]))^2+coef[parindex+3]^2))//          //     peak+=coef[parindex+2]*Aw//           //    break//           case 8://           		//norman model//     //			variable gapsize=coef[parindex+1]//			variable intensity_norman=coef[parindex+2]//			variable gamma1=coef[parindex+3]//			variable gamma0=max(abs(coef[parindex+4]),0.00001)//			//			variable/C nse = cmplx(0,-gamma1)+gapsize^2/cmplx(x,gamma0)//			variable specfunc=-intensity_norman*imag(nse)/((x-real(nse))^2+(imag(nse))^2)//			peak+=specfunc//           		break	           endswitch       else		    switch(fnnum) // The following cases were commented out, because it is not related to RIXS. I kept the code, so that it left clue how to implement anti-stoke into fitting in the future.		    case 1: //xfermi 		    		//fermi = 1/(exp((x-coef[parindex+1]) / (kB*coef[parindex+2]))+1.0 )		    		//gv_Fermiflag=1		    		break 		    case 3://offset		    		//offset = coef[parindex+1] + coef[parindex+2] * x + coef[parindex+3]*x*x		    		//gv_offsetflag=1		    		break		    endswitch	   endif				parindex+=FitPar_parnum[index]		index+=1	while (index<numpnts(FitPar_Fnnum))			//return offset + (peak + bkg) * fermi	return peak + bkg	EndFunction ARPES_composed_FitFn(pw, yw, xw): FitFunc	Wave pw, yw, xw		DFREF DF=GetDatafolderDFR()	String DF_panel="root:internalUse:"+winname(0,65)	DFREF DFR_panel=$DF_panel	DFREF DFR_common=$(DF_panel+":panel_common")	DFREF DFR_fit=$(DF_panel+":Fit_data")		Wave FitPar_Fnnum=DFR_panel:FitPar_Fnnum	Wave FitPar_parnum=DFR_panel:FitPar_parnum			NVAR  gv_symbkgflag=DFR_panel:gv_symbkgflag      NVAR gv_absbkgflag=DFR_panel:gv_absbkgflag		WAVE w_trace = DFR_common:w_trace		init_Fit_wave()		NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	//print gv_convolveflag,pw	if (gv_Convolveflag>0)		WAVE w_fit = DFR_panel:w_fit		WAVE /Z w_conv_gauss = DFR_panel:w_conv_gauss		Variable resol=pw[gv_Convolveflag]				if (Waveexists(w_conv_gauss)==0)			init_convolve_Guassin(resol, w_trace) 		endif		WAVE /Z w_conv_gauss = DFR_panel:w_conv_gauss						w_conv_gauss= exp(-x^2*4*ln(2)/resol^2)   		Variable sumGauss = sum(w_conv_gauss, -inf,inf)    		w_conv_gauss /= sumGauss    			w_fit=0		MultiThread w_fit=composed_FitFn(pw,x,w_trace,FitPar_Fnnum,FitPar_parnum,-1,gv_symbkgflag,gv_absbkgflag)		//MultiThread w_fit=composed_FitFn_test(pw,x,-1,DF_panel)		 	Convolve/A w_conv_gauss w_fit 	else				WAVE w_fit = DFR_panel:w_fit		//duplicate /o w_trace DFR_panel:w_fit		w_fit=0		MultiThread w_fit=composed_FitFn(pw,x,w_trace,FitPar_Fnnum,FitPar_parnum,-1,gv_symbkgflag,gv_absbkgflag)		//MultiThread w_fit=composed_FitFn_test(pw,x,-1,DF_panel)	endif 			yw = w_fit(xw[p])	EndFunction init_Fit_wave()	DFREF DF=GetDatafolderDFR()	String DF_panel="root:internalUse:"+winname(0,65)	DFREF DFR_panel=$DF_panel	DFREF DFR_common=$(DF_panel+":panel_common")	//SetActiveSubwindow $winname(0,65)	DFREF DFR_fit=$(DF_panel+":Fit_data")		NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	Wave CurveFit_coef=DFR_panel:CurveFit_coef		Wave w_trace=DFR_common:w_trace		if (gv_Convolveflag>0)		init_convolve_Guassin(CurveFit_coef[gv_Convolveflag], w_trace)	else		init_disp_fitcurve(DFR_panel,w_trace,"w_fit")	endifEndFunction init_disp_fitcurve(DFR_save,w_trace,peakname)	DFREF DFR_save	Wave w_trace	String peakname		DFREF DF=GetDatafolderDFR()		SetDatafolder DFR_save		variable data_dx, x0, x1		data_dx=deltax(w_trace)	x0=pnt2x(w_trace,0)	x1=pnt2x(w_trace,numpnts(w_trace)-1)		Variable dx = data_dx	// needs to be smaller than the data-width!, not really sure...	Variable y_xfrom = x0 	Variable y_xto = x1				Variable y_pnts = round((y_xto-y_xfrom)/dx)		if (y_pnts<1000)		y_pnts=1000		dx=(y_xto-y_xfrom)/999	endif		Make/o/d/n=(y_pnts) $peakname = 0			SetScale/P x y_xfrom, dx, $peakname		SetDatafolder DFEndFunction init_convolve_Guassin(fwhm, w_trace)	Variable fwhm	Wave w_trace		DFREF DF=GetDatafolderDFR()	String DF_panel="root:internalUse:"+winname(0,65)	DFREF DFR_panel=$DF_panel	DFREF DFR_common=$(DF_panel+":panel_common")	//SetActiveSubwindow $winname(0,65)	DFREF DFR_fit=$(DF_panel+":Fit_data")		SetDatafolder DFR_panel		 	variable data_dx, x0, x1				data_dx=deltax(w_trace)	x0=pnt2x(w_trace,0)	x1=pnt2x(w_trace,numpnts(w_trace)-1)		 			Variable res=10			if (fwhm == 0 || numtype(fwhm) != 0)			fwhm = 0.002		else			fwhm =  abs(fwhm)		endif		Variable gauss_from = 10 * fwhm		Variable dx =  min(fwhm/res, abs(data_dx/5))		// needs to be smaller than the data-width!, not really sure...				Variable y_xfrom		Variable y_xto								if (x0 < x1)			y_xfrom = x0 - 4 * fwhm			y_xto = x1 + 4 * fwhm		else			y_xfrom = x1 - 4 * fwhm			y_xto = x0 + 4 * fwhm		endif				Variable gauss_pnts = round(gauss_from/dx) * 2 + 1		Variable y_pnts = round((y_xto-y_xfrom)/dx)				Make/o/d/n=(gauss_pnts) w_conv_gauss = 0		Make/o/d/n=(y_pnts) w_fit = 0				SetScale/P x y_xfrom, dx, w_fit		SetScale/P x -gauss_from, dx, w_conv_gauss	SetDatafolder DFEnd	//The following function seem not used. commented out by W. S. Lee 01/26/2023//Function init_conv_composed_FF(fwhm, res, data_dx, x0, x1)//	Variable fwhm, res, data_dx, x0, x1//	//	String DF = GetDataFolder (1)//	SetDataFolder root:internalUse:fit//		//	//		if (fwhm == 0 || numtype(fwhm) != 0)//			fwhm = 0.002//		else//			fwhm =  abs(fwhm)//		endif////		Variable gauss_from = 10 * fwhm//		Variable dx =  min(fwhm/res, abs(data_dx/2))		// needs to be smaller than the data-width!, not really sure...//		Variable y_xfrom = x0 - 4 * fwhm//		Variable y_xto = x1 + 4 * fwhm//		//		Variable gauss_pnts = round(gauss_from/dx) * 2 + 1//		Variable y_pnts = round((y_xto-y_xfrom)/dx)//		//		Make/o/d/n=(gauss_pnts) w_conv_gauss = 0//		Make/o/d/n=(y_pnts) w_conv_y = 0//		//		SetScale/P x y_xfrom, dx, w_conv_y//		SetScale/P x -gauss_from, dx, w_conv_gauss//		//	SetDataFolder $DF//End//