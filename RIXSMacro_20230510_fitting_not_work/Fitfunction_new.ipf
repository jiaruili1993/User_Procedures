#pragma rtGlobals=1		// Use modern global access method.//Change Note: W. S. Lee// Try to replace some existing function to make the fitting work for RIXS data.//Changes:// (1) Change xFermi to 1 + N_B(w).  N_B(w) is the Bose distribution// (2) change Lorentz to Anti-LorentzFunction init_FitFN_text(PeakFns,bkgFns,coefFns)	Wave /T PeakFns	Wave /T bkgFns	Wave /T coefFns//  Changed by W. S. Lee. Change Lorentz to Anti_Lorentz, the function form is also changed. //	PeakFns[][0]={{"anti_Lorentz","damped_anti_Lorentz","Lorentz_area","Gauss","Gauss_area","Voigt","Voigt_area","Doniach-Sunjic","Fermi-liquid","marginal-FL","empirical-FL","Dyne-Fn","Sym_Fn","Sym_BCS"}}	PeakFns[][0]={{"anti_Lorentz","damped_anti_Lorentz","anti_Gauss","Gauss_area","Voigt","Voigt_area","Doniach-Sunjic","Fermi-liquid","marginal-FL","empirical-FL","Dyne-Fn","Sym_Fn","Sym_BCS"}}	PeakFns[][1]={{"3","4","3","3","4","4","4","6","6","5","3","4","4"}}	PeakFns[][2]={{"position","position","position","position","position","position","position","position","position","position","Gap","Gap","Gap"}}	PeakFns[][3]={{"intensity","area","intensity","area","intensity","area","intensity","intensity","intensity","intensity","intensity","intensity","intensity"}}	PeakFns[][4]={{"FWHM","FWHM","FWHM","FWHM","FWHM","FWHM","FWHM","impurity","impurity","a0","Scatter1","Scatter1","Scatter1"}}	PeakFns[][5]={{"","temperature","","","shape","shape","asymmetry","beta","lambda","b_x_w","","Scatter0","Scatter0"}}	PeakFns[][6]={{"","","","","","EF","EF","c_x_w2","","","",""}}	PeakFns[][7]={{"","","","","","T","T","","","","",""}}	bkgFns[][0]={{	"constant","linear","2. order polynom","3. order polynom","exponential","polynom-FD","Shirley BG","Shirley iteration","bkg_Lorentz","bkg_Gauss"}}	bkgFns[][1]={{"1","3","4","5","4","5","3","4","3","3"}}	bkgFns[][2]={{	"constant","offset","offset","offset","offset","offset","offset","x0","position","position"}}	bkgFns[][3]={{	"",	"constant","0. order","0. order","constant","constant","constant","x1","intensity","intensity"}}	bkgFns[][4]={{	"",	"slope","1.order",	"1.order","intensity","intensity","scattering","num","FWHM","FWHM"}}	bkgFns[][5]={{	"","","2.order","2.order","decay","EF","","constant","",""}}	bkgFns[][6]={{"","","","3.order","","Tem","","","",""}}	coefFns[][0]={{"xFermi","Convolve","Offset","symbkg"}}	coefFns[][1]={{"2","1","3","1"}}	coefFns[][2]={{"EF","FWHM","0.order","Tbkg"}}	coefFns[][3]={{"T","","1.order",""}}	coefFns[][4]={{"","","2.order",""}}	EndThreadSafe Function composed_FitFn(coef,x,w_trace,w_bkg,FitPar_Fnnum,FitPar_parnum,Fnnum_single,gv_symbkgflag,gv_absbkgflag)	Wave coef	Variable x			Wave w_trace//=DFR_common:w_trace	Wave w_bkg	Wave FitPar_Fnnum//=DFR_panel:FitPar_Fnnum	Wave FitPar_parnum//=DFR_panel:FitPar_parnum	variable  gv_symbkgflag//=DFR_panel:gv_symbkgflag       Variable gv_absbkgflag//=DFR_panel:gv_absbkgflag          Variable Fnnum_single		Variable kB=8.617385e-5 			Variable peak=0,bkg=0,offset=0,fermi=1	Variable fnnum	Variable index,parindex=-1	Variable FackX,bkgtemp		Variable shirleybkgflag=0			index=0 //search symbkg	do		if (index>=numpnts(FitPar_Fnnum))			break		endif		fnnum= FitPar_Fnnum[index]		if (fnnum==4)			Variable Tbkg=coef[parindex+1]			break		endif		parindex+=FitPar_parnum[index]		index+=1	while (index<numpnts(FitPar_Fnnum))	parindex=-1		    			    			index=0		//NVAR gv_Fermiflag=DFR_panel:gv_Fermiflag    // NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	//NVAR gv_Offsetflag=DFR_panel:gv_Offsetflag   	do				if (index>=numpnts(FitPar_Fnnum))			break		endif		fnnum= FitPar_Fnnum[index]				if (Fnnum_single>=0)			if (index!=Fnnum_single)				parindex= parindex+FitPar_parnum[index]				index+=1				continue			endif		endif					if (fnnum>=400)//bkg			fnnum-=400			FackX=x						if (gv_symbkgflag)				x=-x				switch(fnnum)				case 0:							bkgtemp= coef[parindex+1]					break				case 1:							bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1])					break										case 2:							bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1])					break				case 3:							bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1]) + coef[parindex+5]*(x-coef[parindex+1])*(x-coef[parindex+1])*(x-coef[parindex+1])					break							case 4:								bkgtemp= coef[parindex+2] + coef[parindex+3]* exp(-(x-coef[parindex+1])/coef[parindex+4])					break				case 5:					bkgtemp= (coef[parindex+2]+coef[parindex+3]*(x-coef[parindex+1])^2) / (exp( (x-coef[parindex+4])/abs(coef[parindex+5]*KB))+1)					break				case 6:					if (x>coef[parindex+1])						bkgtemp=0					else						bkgtemp=coef[parindex+3] * area(w_bkg, x,coef[parindex+1])+coef[parindex+2]					endif					shirleybkgflag=1					break				case 7:					bkgtemp=w_bkg(x)+coef[parindex+4] //calShirleyBG(x,w_trace,coef[parindex+1],coef[parindex+2],coef[parindex+3])					shirleybkgflag=2					break				case 8:					bkgtemp = (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)					break					case 9:					variable aux0 = 2*sqrt(ln(2))					bkgtemp = coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) 					break				endswitch									if (gv_absbkgflag)					bkgtemp=(bkgtemp<0)?(0):bkgtemp				endif								bkg+=bkgtemp*1/(exp((x) / (kB*Tbkg))+1.0 )							endif						x=FackX						switch(fnnum)			case 0:						bkgtemp= coef[parindex+1]				break			case 1:						bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1])				break									case 2:						bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1])				break			case 3:						bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1]) + coef[parindex+5]*(x-coef[parindex+1])*(x-coef[parindex+1])*(x-coef[parindex+1])				break						case 4:							bkgtemp= coef[parindex+2] + coef[parindex+3]* exp(-(x-coef[parindex+1])/coef[parindex+4])				break			case 5:				bkgtemp= (coef[parindex+2]+coef[parindex+3]*(x-coef[parindex+1])^2) / (exp( (x-coef[parindex+4])/abs(coef[parindex+5]*KB))+1)				break			case 6:				if (x>coef[parindex+1])					bkgtemp=0				else					bkgtemp=coef[parindex+3] * area(w_bkg, x,coef[parindex+1])+coef[parindex+2]				endif				shirleybkgflag=1				break			case 7:				bkgtemp=w_bkg(x)+coef[parindex+4] //calShirleyBG(x,w_trace,coef[parindex+1],coef[parindex+2],coef[parindex+3])				shirleybkgflag=2				break			case 8:				bkgtemp = (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)				break				case 9:				 aux0 = 2*sqrt(ln(2))				bkgtemp = coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) 				break			endswitch						if (gv_absbkgflag)				bkgtemp=(bkgtemp<0)?(0):bkgtemp			endif							if (gv_symbkgflag)				bkg+=bkgtemp*1/(exp((x) / (kB*Tbkg))+1.0 )			else				bkg+=bkgtemp			endif					elseif (fnnum>=200)//Peak			fnnum-=200			switch(fnnum)				case 0:						// Lorentzian_amp				//peak += (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)								// Modified by W. S. Lee				// Change it to an Anti-Lorentizan function with only the energy losss side. Note : The sign was retrofited such that the energy loss is negative in energy and the energy gain side of the spectrum is set to zero.				// Modified by Haiyu Lu				// Change the sign such that the energy loss is positive in energy				peak += abs((x>=0)*((coef[parindex+2]/pi*coef[parindex+3]/2) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4) - (coef[parindex+2]/pi*coef[parindex+3]/2) / ((x+coef[parindex+1])^2+coef[parindex+3]^2/4)))								break			case 1:						// Lorentzian_area				//peak += (coef[parindex+2]/pi*coef[parindex+3]/2) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)				//damped anti Lorentzian				peak += 1/(1-exp(-x/(kB*coef[parindex+4])))*((coef[parindex+2]/pi*coef[parindex+3]/2) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4) - (coef[parindex+2]/pi*coef[parindex+3]/2) / ((x+coef[parindex+1])^2+coef[parindex+3]^2/4))				break									case 2:						// Gaussian_amp					//aux0 = 2*sqrt(ln(2))				//peak += coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2)								//Modified by W. S. Lee				//Change it to an Anti-Gaussian with only the energy loss side. See note in the case 0:								aux0 = 2*sqrt(ln(2))				peak += abs((x>=0) *(coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) - coef[parindex+2]*exp(-((x+coef[parindex+1])/(coef[parindex+3]/aux0))^2)))				 				break			case 3:						// Gaussian_area						aux0 = 2*sqrt(ln(2))				peak += coef[parindex+2]/(sqrt(2*pi)*(coef[parindex+3]/aux0))*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) 				break			case 4:				// A fitting function utilizing the Voigt profile (a convolution between a				// Gaussian and a Lorentzian). Can handle a number of peaks depending on the				// number of points in the coefficient wave w. If w contains 5 points then one				// peak will be generated as follows: 				// w[0]+w[1]*Voigt(w[2]*(x-w[3]),w[4])				// Parameter w[0] sets the DC offset, w[1] sets the amplitude, w[2]  affects the				// width, w[3] sets the location of the peak and w[4] adjusts the shape (but also				// affects the amplitude). 				// After the fit, you can use the returned coefficients to calculate the area (a)				// along with the half width at half max for the Gaussian (wg), Lorentzian (wl)				// and the Voigt (wv). Assuming the coefficient wave is named coef: 				// 	a= coef[1]*sqrt(pi)/coef[2]				// 	wg= sqrt(ln(2))/coef[2]				// 	wl= coef[4]/coef[2] 				// 	wv= wl/2 + sqrt( wl^2/4 + wg^2)				// See Tech Note TN026 for more information about the Voigt.								peak += coef[parindex+2]*fVoigt_Igor(sqrt(ln(2))*2/coef[parindex+3]*(x-coef[parindex+1]),coef[parindex+4])						break			case 5:					peak += coef[parindex+2]/sqrt(pi)*(sqrt(ln(2))*2/coef[parindex+3])*fVoigt_Igor(sqrt(ln(2))*2/coef[parindex+3]*(x-coef[parindex+1]),coef[parindex+4])					break				case 6:					// Doniach-Sunjic				// w0: position				// w1: intensity				// w2: gamma							// w3: alpha				variable ds0 =coef[parindex+2]*cos(pi*coef[parindex+4]/2+(1-coef[parindex+4])*atan((x-coef[parindex+1])/coef[parindex+3])) 	// nominator				variable ds1 = ((x-coef[parindex+1])^2+coef[parindex+3]^2)^((1-coef[parindex+4])/2)									// denominator				peak += ds0/ds1				break			case 7:				// Fermi-liquid				// requires Fermi-funciton parameters				aux0 = coef[parindex+3] +coef[parindex+4]* ((x-coef[parindex+5])^2 + (pi*kB*coef[parindex+6])^2)	// self energy with impurity scattering				//peak += (w[par0+1]*aux0^2/pi) / ((x-w[par0])^2+aux0^2)	// corrected 06-08-04				peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2)				break			case 8:				// marginal Fermi-liquid				// requires Fermi-funciton parameters				aux0 = coef[parindex+3] + coef[parindex+4]* pi*0.5*sqrt((x-coef[parindex+5])^2 + (pi*kB*coef[parindex+6])^2) //corrected 2012-12-16		// self energy with impurity scattering				peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2)				break			case 9:				// "empirical FL"				aux0 = coef[parindex+3] + coef[parindex+4]*x + coef[parindex+5]*x*x				peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2/4)				break	       	case 10:	           		//dyne function	          		 variable /C E=cmplx(x,0)				variable /C Gap=cmplx(coef[parindex+1],0)				variable /C GGamma=cmplx(0,coef[parindex+3])				peak += abs(coef[parindex+2]*real((E-GGamma)/(sqrt((E-GGamma)*(E-GGamma)-Gap*Gap))))	           		break	     		 case 11:	          		 // SC spectra function	          		 if (x==0)  					Variable Aw=1/pi/coef[parindex+3]				else					Variable SelfEIm=-coef[parindex+3]-coef[parindex+1]^2*coef[parindex+4]/(x^2+coef[parindex+4]^2)					Variable SelfERe=coef[parindex+1]^2*x/(x^2+coef[parindex+4]^2)					 Aw=1/pi*SelfEIm/((x-SelfERe)*(x-SelfERe)+SelfEIm*SelfEIm)				endif				peak+=-coef[parindex+2]*Aw	          		//make /o/n=4 symEDCcof              		// symEDCcof=w[par0+p]              		// peak += CalsymEDCfit(symEDCcof,x)             			 break          			// case 8:                		// BCS spectra function             			//    Aw=0.5/pi*(coef[parindex+3]/((x-abs(coef[parindex+1]))^2+coef[parindex+3]^2)+coef[parindex+3]/((x+abs(coef[parindex+1]))^2+coef[parindex+3]^2))          			//     peak+=coef[parindex+2]*Aw           			//    break           		case 12:				//gapped SC lineshape, only valid for Kf				variable /C sigma, Green, sig_gap, sig_FL, sig_gap_num, sig_gap_dom, sig				variable gamma0								sig_gap_num = cmplx(coef[parindex+1]*coef[parindex+1],0)								//gamma0 = abs(w[par0+1]) + abs(w[par0+2])*abs(x)+abs(w[par0+3])*abs(x)^3  // The phenomenology model from PRB 57, pR11093								if (  x > abs(coef[parindex+1]) || x < (-1*abs(coef[parindex+1]))    )								gamma0 = abs(coef[parindex+3]) + abs(coef[parindex+4])* sqrt(x^2-coef[parindex+1]^2)/abs(x)				else				gamma0 = abs(coef[parindex+3])				endif					 				sig_gap_dom = cmplx(x, gamma0) // might need to be modified to cmplx(x,w[par0+2]) to avoid always non-zero in-gap scattering HY, May 9, 2013									sig_gap = sig_gap_num/sig_gap_dom								sig = sig_gap - cmplx(0,1)*gamma0								Green = coef[parindex+2] / ( x- sig)								peak +=  -imag(Green) / pi				break                      		break	           endswitch       else		    switch(fnnum)		    case 1: //xfermi		    		fermi = 1/(exp((x-coef[parindex+1]) / (kB*coef[parindex+2]))+1.0 )		    		//gv_Fermiflag=1		    		break 		    case 3://offset		    		offset = coef[parindex+1] + coef[parindex+2] * x + coef[parindex+3]*x*x		    		//gv_offsetflag=1		    		break		    endswitch	   endif				parindex+=FitPar_parnum[index]		index+=1	while (index<numpnts(FitPar_Fnnum))		Variable calx=x		if ((shirleybkgflag==1)&&(Fnnum_single==-2))		return peak	endif			return offset + (peak + bkg) * fermi	EndFunction calShirleyBG(w_trace,w_bkg,coef,Fnnum,Parnum)	Wave w_trace	Wave w_bkg	Wave coef	Wave Fnnum	Wave Parnum		Variable fnnum_var		Variable index=0 //search Shirleybkg	Variable parindex=-1	do		if (index>=numpnts(Fnnum))			break		endif		fnnum_var= Fnnum[index]		if (fnnum_var==407)			Variable x0=coef[parindex+1]			Variable x1=coef[parindex+2]			Variable num=coef[parindex+3]			break		endif		parindex+=Parnum[index]		index+=1	while (index<numpnts(Fnnum))		Duplicate /o /Free w_bkg,data,data_bkg,bkg,bkg2		data=w_trace(x)	Variable I0=data(x0)	Variable I1=data(x1)		data_bkg=data-I0		Variable k=(I1-I0)/(-area(data_bkg,x0,x1))	index=0	do		bkg=k*(-area(data_bkg,x0,x))		data_bkg=data-I0-bkg				data_bkg=(data_bkg<0)?(0):(data_Bkg)		//doupdate;				k=(I1-I0)/(-area(data_bkg,x0,x1))			bkg2=k*(-area(data_bkg,x0,x))		//print k		index+=1	while (index<num)		w_bkg=bkg2	End			variable px	Wave data	variable x0	variable x1	Variable num		// Returns the Voigt profile (a convolution between a Gaussian and a Lorentzian).// Y is the shape parameter. When Y is zero, the Voigt function is 100% Gaussian// and transitions to 100% Lorentzian as Y approaches infinity. When Y is one the// mix is 50/50. // // The algorithm used is described in TN026. Its relative accuracy is better than// 0.0001 and most of the time is much better. threadsafe Function fVoigt_Igor(X,Y)	variable X,Y		Y= abs(Y)	X= abs(X)	variable/C W,U,T= cmplx(Y,-X)	variable S= X+Y	if( S >= 15 )								//        Region I		W= T*0.5641896/(0.5+T*T)	else		if( S >= 5.5 ) 							//        Region II			U= T*T			W= T*(1.410474+U*0.5641896)/(0.75+U*(3+U))		else			if( Y >= (0.195*X-0.176) ) 	//        Region III				W= (16.4955+T*(20.20933+T*(11.96482+T*(3.778987+T*0.5642236))))				W /= (16.4955+T*(38.82363+T*(39.27121+T*(21.69274+T*(6.699398+T)))))			else									//        Region IV				U= T*T				W= T*(36183.31-U*(3321.9905-U*(1540.787-U*(219.0313-U*(35.76683-U*(1.320522-U*0.56419))))))				W /= (32066.6-U*(24322.84-U*(9022.228-U*(2186.181-U*(364.2191-U*(61.57037-U*(1.841439-U)))))))				W= cmplx(exp(real(U))*cos(imag(U)),0)-W			endif		endif	endif	return real(W)endFunction return_draw_steps(fnnum)	Variable fnnum		Variable steps		if (fnnum>=400) ///bkg		fnnum-=400		switch(fnnum)			case 0:					steps=1				break				case 1:				steps=2				break							case 2:						steps=3				break			case 3:						steps=4				break						case 4:							steps=2				break			case 5:				steps=4				break			case 6:				steps=2				break			case 7:				steps=2				break			case 8:				steps=2			case 9:				steps=2				break		endswitch	elseif (fnnum>=200)		fnnum-=200				switch(fnnum)			case 0:						steps=2				break			case 1:						steps=2				break			case 2:						steps=2				break			case 3:						steps=2				break			case 4:						steps=2				break			case 5:						steps=2				break			case 6:						steps=3				break			case 7:						steps=2				break				case 8:						steps=2				break				case 9:						steps=2				break			case 10:						steps=2				break			case 11:						steps=2				break			case 12:						steps=2				break			endswitch			else			switch(fnnum)			case 1:					steps=2				break			case 2:				steps=0				break			case 3:				steps=3				break							endswitch	endif	return stepsEndFunction UpdatePeak(xaxval,yaxval,w_trace,coef,fnnum,parindex,mode,xremember,yremember)  	Variable xaxval,yaxval  	Wave w_trace  	Wave coef  	Variable fnnum,parindex  	Variable mode,xremember,yremember  	if (fnnum>=400) ///bkg		fnnum-=400		switch(fnnum)			case 0:					if (mode==1)						coef[parindex+1]=yaxval//=wavemin(w_trace,x0,x1)				endif				break				case 1:				if (mode==1)					coef[parindex+1]=xaxval//coef_temp[0]					coef[parindex+2]=yaxval					coef[parindex+3]=0				elseif (mode==2)										coef[parindex+3]=(yaxval-coef[parindex+2])/(xaxval-coef[parindex+1])				endif				break							case 2:						if (mode==1)					coef[parindex+1]=xaxval//coef_temp[0]					coef[parindex+2]=yaxval					coef[parindex+3]=0					coef[parindex+4]=0				elseif (mode==2)					coef[parindex+3]=(yaxval-coef[parindex+2])/(xaxval-coef[parindex+1])				elseif (mode==3)					coef[parindex+4]=(yaxval-coef[parindex+2]-(xaxval-coef[parindex+1])*coef[parindex+3])/((xaxval-coef[parindex+1])*(xaxval-coef[parindex+1]))				endif				//coef_temp[2]//*x + coef[parindex+3]*x*x				break			case 3:						if (mode==1)					coef[parindex+1]=xaxval//coef_temp[0]					coef[parindex+2]=yaxval					coef[parindex+3]=0					coef[parindex+4]=0					coef[parindex+5]=0				elseif (mode==2)					coef[parindex+3]=(yaxval-coef[parindex+2])/(xaxval-coef[parindex+1])				elseif (mode==3)					coef[parindex+4]=(yaxval-coef[parindex+2]-(xaxval-coef[parindex+1])*coef[parindex+3])/((xaxval-coef[parindex+1])*(xaxval-coef[parindex+1]))				elseif (mode==4)					coef[parindex+5]=(yaxval-coef[parindex+2]-(xaxval-coef[parindex+1])*coef[parindex+3]-coef[parindex+4]*(xaxval-coef[parindex+1])*(xaxval-coef[parindex+1]))/((xaxval-coef[parindex+1])*(xaxval-coef[parindex+1])*(xaxval-coef[parindex+1]))				endif				break						case 4:					if (mode==1)					coef[parindex+1]=xaxval//coef_temp[0]					coef[parindex+2]=yaxval					coef[parindex+3]=0					coef[parindex+4]=10000				elseif (mode==2)					coef[parindex+2]=(yremember*exp(1)-yaxval)/(exp(1)-1)					coef[parindex+3]=(yaxval-yremember)/(exp(1)-1)						coef[parindex+4]=-(xaxval-coef[parindex+1])					//coef[parindex+2]-=coef[parindex+3]				//elseif (mode==3)					//	coef[parindex+4]=ln((yaxval-coef[parindex+2])/coef[parindex+3])/(coef[parindex+1]-xaxval)					//coef[parindex+4]=ln((yaxval-coef[parindex+1])/coef[parindex+2])*coef[parindex+3]+xaxval				endif				break			case 5:				if (mode==1)					coef[parindex+1]=xaxval//coef_temp[0]					coef[parindex+2]=yaxval					coef[parindex+3]=0					coef[parindex+4]=10000					coef[parindex+5]=300				elseif (mode==2)					coef[parindex+3]=(yaxval-coef[parindex+2])/(xaxval-coef[parindex+1])^2				elseif (mode==3)					coef[parindex+4]=xaxval				elseif (mode==4)					Variable kB=8.617385e-5 						coef[parindex+5]=abs(xaxval-coef[parindex+4])/4/KB				endif				break			case 6:				if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval					coef[parindex+3]=0				else					coef[parindex+3]=(yaxval-coef[parindex+2])/area(w_trace, xaxval,coef[parindex+1])				endif				//bkg += coef[parindex+1] * area(w_trace, x,0)					break			case 7:				if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=leftx(w_trace)					coef[parindex+3]=10					coef[parindex+4]=0				else					coef[parindex+2]=xaxval				endif				//bkg += coef[parindex+1] * area(w_trace, x,0)					break								case 8:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval					coef[parindex+3]=0.05				else					coef[parindex+3]=abs(xaxval-coef[parindex+1])				endif				break			case 9:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval					coef[parindex+3]=0.05				else					coef[parindex+3]=abs(xaxval-coef[parindex+1])				endif				break		endswitch	elseif (fnnum>=200)		fnnum-=200					switch(fnnum)			case 0:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval					coef[parindex+3]=0.05				else					coef[parindex+3]=2*abs(xaxval-coef[parindex+1])				endif				break			case 1:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval*pi*0.05/2					coef[parindex+3]=0.05				else					coef[parindex+3]=2*abs(xaxval-coef[parindex+1])					coef[parindex+2]=yremember*pi*coef[parindex+3]/2				endif				break							case 2:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval					coef[parindex+3]=0.05				else					coef[parindex+3]=2*abs(xaxval-coef[parindex+1])				endif				break				case 3:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval*sqrt(2*pi)*coef[parindex+3]/(2*sqrt(ln(2)))					coef[parindex+3]=0.05				else										coef[parindex+3]=2*abs(xaxval-coef[parindex+1])					coef[parindex+2]=yremember*sqrt(2*pi)*coef[parindex+3]/(2*sqrt(ln(2)))				endif				break								case 4:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval					coef[parindex+3]=0.05					coef[parindex+4]=0				else					coef[parindex+3]=2*abs(xaxval-coef[parindex+1])//(2*sqrt(ln(2)))				endif				break			case 5:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval*sqrt(pi)/(sqrt(ln(2))*2/0.05)					coef[parindex+3]=0.05					coef[parindex+4]=0				else										coef[parindex+3]=2*abs(xaxval-coef[parindex+1])					coef[parindex+2]=yremember*sqrt(pi)/(sqrt(ln(2))*2/coef[parindex+3])				endif				break					case 6:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval/50					coef[parindex+3]=0.05					coef[parindex+4]=0				elseif(mode==2)					coef[parindex+3]=abs(xaxval-coef[parindex+1])						elseif (mode==3)							coef[parindex+4]=abs(xaxval-coef[parindex+1])-coef[parindex+3]				endif				break			case 7:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval/50					coef[parindex+3]=0.05					coef[parindex+4]=0					coef[parindex+5]=0					coef[parindex+6]=15				else					coef[parindex+3]=abs(xaxval-coef[parindex+1])				endif				break			case 8:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval/50					coef[parindex+3]=0.05					coef[parindex+4]=0					coef[parindex+5]=0					coef[parindex+6]=15				else					coef[parindex+3]=abs(xaxval-coef[parindex+1])				endif				break				case 9:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=yaxval/50					coef[parindex+3]=0.01					coef[parindex+4]=0					coef[parindex+5]=0					coef[parindex+6]=0				else					coef[parindex+3]=abs(xaxval-coef[parindex+1])				endif								break			case 10:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+3]=0.01					variable /C E=cmplx(xaxval,0)					variable /C Gap=cmplx(xaxval,0)					variable /C GGamma=cmplx(0,0.1)					Variable peak = abs(real((E-GGamma)/(sqrt((E-GGamma)*(E-GGamma)-Gap*Gap))))					coef[parindex+2]=yaxval/peak				else					coef[parindex+3]=abs(xaxval-coef[parindex+1])/10				endif				break			case 11:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+3]=0.01					coef[parindex+4]=0										if (xaxval==0)	  						Variable Aw=1/pi/coef[parindex+3]  					else						Variable SelfEIm=-coef[parindex+3]-coef[parindex+1]^2*coef[parindex+4]/(xaxval^2+coef[parindex+4]^2)						Variable SelfERe=coef[parindex+1]^2*x/(xaxval^2+coef[parindex+4]^2)						 Aw=1/pi*SelfEIm/((x-SelfERe)*(x-SelfERe)+SelfEIm*SelfEIm)					endif										coef[parindex+2]=-yaxval/aw				else					coef[parindex+3]=abs(xaxval-coef[parindex+1])				endif				break			case 12:						if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+3]=0.01					Aw=0.5/pi*(coef[parindex+3]/((xaxval-abs(coef[parindex+1]))^2+coef[parindex+3]^2)+coef[parindex+3]/((xaxval+abs(coef[parindex+1]))^2+coef[parindex+3]^2))        				coef[parindex+2]=yaxval/aw 				else					coef[parindex+3]=abs(xaxval-coef[parindex+1])				endif				break			endswitch			else			switch(fnnum)			case 1:					if (mode==1)					coef[parindex+1]=xaxval					coef[parindex+2]=15				else					kB=8.617385e-5 						coef[parindex+2]=abs(xaxval-coef[parindex+1])/4/KB				endif				break			case 2:				coef[parindex+5]=0.01				break			case 3:				if (mode==1)					coef[parindex+1]=yaxval//coef_temp[0]					coef[parindex+2]=0					coef[parindex+3]=0				elseif (mode==2)					coef[parindex+2]=(yaxval-coef[parindex+1])/xaxval				elseif (mode==3)					coef[parindex+3]=(yaxval-coef[parindex+1]-xaxval*coef[parindex+2])/(xaxval*xaxval)				endif				break							endswitch	endif 	 	 	update_Coef_to_Listbox()	update_coef_to_SavePara()	update_display_curve(1) EndFunction ARPES_composed_FitFn(pw, yw, xw): FitFunc	Wave pw, yw, xw		DFREF DF=GetDatafolderDFR()	String DF_panel="root:internalUse:"+winname(0,65)	DFREF DFR_panel=$DF_panel	DFREF DFR_common=$(DF_panel+":panel_common")	DFREF DFR_fit=$(DF_panel+":Fit_data")		Wave FitPar_Fnnum=DFR_panel:FitPar_Fnnum	Wave FitPar_parnum=DFR_panel:FitPar_parnum			NVAR  gv_symbkgflag=DFR_panel:gv_symbkgflag      NVAR gv_absbkgflag=DFR_panel:gv_absbkgflag		WAVE w_trace = DFR_common:w_trace		SetDatafolder DFR_panel		init_Fit_wave()		NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	//print gv_convolveflag,pw	if (gv_Convolveflag>0)		WAVE w_fit = DFR_panel:w_fit		WAVE /Z w_Gaussian = DFR_panel:w_Gaussian		//Variable resol=pw[gv_Convolveflag]				//if (Waveexists(w_conv_gauss)==0)		//	init_convolve_Guassin(resol, w_trace) 		//endif		//WAVE /Z w_conv_gauss = DFR_panel:w_conv_gauss			Variable aux0= 4*ln(2)/pw[gv_Convolveflag]^2		w_Gaussian = exp(-x^2*aux0) / ( sqrt(pi/aux0) )/// dx )		// norm=dx              		Variable sumGauss = sum(w_Gaussian, -inf,inf)    		w_Gaussian /= sumGauss					w_fit=0				//MultiThread w_fit=composed_FitFn(pw,x,w_trace,w_bkg,FitPar_Fnnum,FitPar_parnum,-1,gv_symbkgflag,gv_absbkgflag)		//if (x2pnt(w_fit,xw)==0)						if (SearchNuminwave(FitPar_Fnnum,406)!=-1)				init_disp_fitcurve(DFR_panel,w_trace,"w_bkg")				Wave w_bkg=DFR_panel:w_bkg				MultiThread w_bkg=composed_FitFn(pw,x,w_trace,w_bkg,FitPar_Fnnum,FitPar_parnum,-2,gv_symbkgflag,gv_absbkgflag)			elseif (SearchNuminwave(FitPar_Fnnum,407)!=-1)				init_disp_fitcurve(DFR_panel,w_trace,"w_bkg")				Wave w_bkg=DFR_panel:w_bkg				calShirleyBG(w_trace,w_bkg,pw,FitPar_Fnnum,FitPar_parnum)			endif		//endif					MultiThread w_fit=composed_FitFn(pw,x,w_trace,w_bkg,FitPar_Fnnum,FitPar_parnum,-1,gv_symbkgflag,gv_absbkgflag)		//MultiThread w_fit=composed_FitFn_test(pw,x,-1,DF_panel)			 	Convolve/A w_Gaussian w_fit 	else				WAVE w_fit = DFR_panel:w_fit		//duplicate /o w_trace DFR_panel:w_fit		w_fit=0		//if (x2pnt(w_fit,xw)==0)			init_disp_fitcurve(DFR_panel,w_trace,"w_bkg")			Wave w_bkg=DFR_panel:w_bkg			if (SearchNuminwave(FitPar_Fnnum,406)!=-1)				init_disp_fitcurve(DFR_panel,w_trace,"w_bkg")				Wave w_bkg=DFR_panel:w_bkg				MultiThread w_bkg=composed_FitFn(pw,x,w_trace,w_bkg,FitPar_Fnnum,FitPar_parnum,-2,gv_symbkgflag,gv_absbkgflag)			elseif (SearchNuminwave(FitPar_Fnnum,407)!=-1)				init_disp_fitcurve(DFR_panel,w_trace,"w_bkg")				Wave w_bkg=DFR_panel:w_bkg				calShirleyBG(w_trace,w_bkg,pw,FitPar_Fnnum,FitPar_parnum)			endif		//endif					MultiThread w_fit=composed_FitFn(pw,x,w_trace,w_bkg,FitPar_Fnnum,FitPar_parnum,-1,gv_symbkgflag,gv_absbkgflag)				//MultiThread w_fit=composed_FitFn_test(pw,x,-1,DF_panel)	endif 			yw = w_fit(xw[p])		SetDatafolder dFEndFunction init_Fit_wave()	DFREF DF=GetDatafolderDFR()	String DF_panel="root:internalUse:"+winname(0,65)	DFREF DFR_panel=$DF_panel	DFREF DFR_common=$(DF_panel+":panel_common")	//SetActiveSubwindow $winname(0,65)	DFREF DFR_fit=$(DF_panel+":Fit_data")		NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	Wave CurveFit_coef=DFR_panel:CurveFit_coef		Wave w_trace=DFR_common:w_trace		SetDatafolder DFR_panel		if (gv_Convolveflag>0)		ConvolveResolutionInt(w_trace,CurveFit_coef[gv_Convolveflag],10)				//init_convolve_Guassin(CurveFit_coef[gv_Convolveflag], w_trace)	else		init_disp_fitcurve(DFR_panel,w_trace,"w_fit")		//	endif		SetDatafolder DFEndFunction init_disp_fitcurve(DFR_save,w_trace,peakname)	DFREF DFR_save	Wave w_trace	String peakname		DFREF DF=GetDatafolderDFR()		SetDatafolder DFR_save		variable data_dx, x0, x1		data_dx=deltax(w_trace)	x0=pnt2x(w_trace,0)	x1=pnt2x(w_trace,numpnts(w_trace)-1)		Variable dx = data_dx	// needs to be smaller than the data-width!, not really sure...	Variable y_xfrom = x0 	Variable y_xto = x1				Variable y_pnts = round((y_xto-y_xfrom)/dx)		if (y_pnts<1000)		y_pnts=1000		dx=(y_xto-y_xfrom)/999	endif		Make/o/d/n=(y_pnts) $peakname = 0			SetScale/P x y_xfrom, dx, $peakname		SetDatafolder DFEnd	Function init_conv_composed_FF(fwhm, res, data_dx, x0, x1)	Variable fwhm, res, data_dx, x0, x1		String DF = GetDataFolder (1)	SetDataFolder root:internalUse:fit					if (fwhm == 0 || numtype(fwhm) != 0)			fwhm = 0.002		else			fwhm =  abs(fwhm)		endif		Variable gauss_from = 10 * fwhm		Variable dx =  min(fwhm/res, abs(data_dx/2))		// needs to be smaller than the data-width!, not really sure...		Variable y_xfrom = x0 - 4 * fwhm		Variable y_xto = x1 + 4 * fwhm				Variable gauss_pnts = round(gauss_from/dx) * 2 + 1		Variable y_pnts = round((y_xto-y_xfrom)/dx)				Make/o/d/n=(gauss_pnts) w_conv_gauss = 0		Make/o/d/n=(y_pnts) w_conv_y = 0				SetScale/P x y_xfrom, dx, w_conv_y		SetScale/P x -gauss_from, dx, w_conv_gauss			SetDataFolder $DFEnd