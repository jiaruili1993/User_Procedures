#pragma rtGlobals=1		// Use modern global access method.Function init_FitFN_text(PeakFns,bkgFns,coefFns)	Wave /T PeakFns	Wave /T bkgFns	Wave /T coefFns	PeakFns[][0]={{"Anti-Lorentz","Gauss","Lorentz","Pearson VII","Pseudo-Voigt"}}		PeakFns[][1]={{"3","3","3","4","5"}}	PeakFns[][2]={{"position","position","position","position","position"}}	PeakFns[][3]={{"intensity","intensity","intensity","intensity","AL"}}	PeakFns[][4]={{"FWHM","FWHM","FWHM","FWHM","wL"}}	PeakFns[][5]={{"","","","shape","AG"}}	PeakFns[][6]={{"","","","","wG"}}	//PeakFns[][0]={{"Anti-Lorentz","Gauss","Doniach-Sunjic","Fermi-liquid","marginal-FL","Lorentz","Dyne-Fn","Sym_Fn","Sym_BCS"}}	//PeakFns[][1]={{"3","3","4","6","6","3","3","4","4","2"}}	//PeakFns[][2]={{"position","position",	"position","position","position","position","Gap","Gap","Gap"}}	//PeakFns[][3]={{"intensity","intensity","intensity","intensity","intensity","intensity","intensity","intensity","intensity"}}	//PeakFns[][4]={{"FWHM","FWHM","FWHM","impurity","impurity","FWHM","Scatter1","Scatter1","Scatter1"}}	//PeakFns[][5]={{"","","asymmetry","beta","lambda","","","Scatter0","Scatter0"}}	//PeakFns[][6]={{"","","","EF","EF","","","","",""}}	//PeakFns[][7]={{"","","","T","T","","","","",""}}	bkgFns[][0]={{	"constant","linear","2. order polynom","3. order polynom","exponential","polynom-FD","Shirley BG","bkg_Lorentz","bkg_Gauss"}}	bkgFns[][1]={{"1","3","4","5","4","5","3","3","3"}}	bkgFns[][2]={{	"constant","offset","offset","offset","offset","offset","offset","position","position"}}	bkgFns[][3]={{	"",	"constant","0. order","0. order","constant","constant","constant","intensity","intensity"}}	bkgFns[][4]={{	"",	"slope","1.order",	"1.order","intensity","intensity","intensity","FWHM","FWHM"}}	bkgFns[][5]={{	"","","2.order","2.order","decay","EF","","",""}}	bkgFns[][6]={{"","","","3.order","","Tem","","",""}}	coefFns[][0]={{"xFermi","Convolve","Offset","symbkg"}}	coefFns[][1]={{"2","1","3","1"}}	coefFns[][2]={{"EF","FWHM","0.order","Tbkg"}}	coefFns[][3]={{"T","","1.order",""}}	coefFns[][4]={{"","","2.order",""}}	EndThreadSafe Function composed_FitFn(coef,x,w_trace,FitPar_Fnnum,FitPar_parnum,Fnnum_single,gv_symbkgflag,gv_absbkgflag)	Wave coef	Variable x			Wave w_trace//=DFR_common:w_trace	Wave FitPar_Fnnum//=DFR_panel:FitPar_Fnnum	Wave FitPar_parnum//=DFR_panel:FitPar_parnum	variable  gv_symbkgflag//=DFR_panel:gv_symbkgflag       Variable gv_absbkgflag//=DFR_panel:gv_absbkgflag           Variable Fnnum_single		Variable kB=8.617385e-5 			Variable peak=0,bkg=0,offset=0,fermi=1	Variable fnnum	Variable index,parindex=-1	Variable FackX,bkgtemp			index=0 //search symbkg	do		if (index>=numpnts(FitPar_Fnnum))			break		endif		fnnum= FitPar_Fnnum[index]		if (fnnum==4)			Variable Tbkg=coef[parindex+1]		endif		parindex+=FitPar_parnum[index]		index+=1	while (index<numpnts(FitPar_Fnnum))	parindex=-1		    			    			index=0		//NVAR gv_Fermiflag=DFR_panel:gv_Fermiflag    // NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	//NVAR gv_Offsetflag=DFR_panel:gv_Offsetflag   	do				if (index>=numpnts(FitPar_Fnnum))			break		endif		fnnum= FitPar_Fnnum[index]				if (Fnnum_single>=0)			if (index!=Fnnum_single)				parindex= parindex+FitPar_parnum[index]				index+=1				continue			endif		endif					if (fnnum>=400)//bkg			fnnum-=400			FackX=x						if (gv_symbkgflag)				x=-x				switch(fnnum)				case 0:							bkgtemp= coef[parindex+1]					break				case 1:							bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1])					break										case 2:							bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1])					break				case 3:							bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1]) + coef[parindex+5]*(x-coef[parindex+1])*(x-coef[parindex+1])*(x-coef[parindex+1])					break							case 4:								bkgtemp= coef[parindex+2] + coef[parindex+3]* exp(-(x-coef[parindex+1])/coef[parindex+4])					break				case 5:					bkgtemp= (coef[parindex+2]+coef[parindex+3]*(x-coef[parindex+1])^2) / (exp( (x-coef[parindex+4])/abs(coef[parindex+5]*KB))+1)					break				case 6:					bkgtemp= coef[parindex+3] * area(w_trace, x,coef[parindex+1])+coef[parindex+2]					break				case 7:					bkgtemp = (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)					break					case 8:					variable aux0 = 2*sqrt(ln(2))					bkgtemp = coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) 					break				endswitch									if (gv_absbkgflag)					bkgtemp=(bkgtemp<0)?(0):bkgtemp				endif								bkg+=bkgtemp*1/(exp((x) / (kB*Tbkg))+1.0 )							endif						x=FackX						switch(fnnum)			case 0:						bkgtemp= coef[parindex+1]				break			case 1:						bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1])				break									case 2:						bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1])				break			case 3:						bkgtemp= coef[parindex+2] + coef[parindex+3]*(x-coef[parindex+1]) + coef[parindex+4]*(x-coef[parindex+1])*(x-coef[parindex+1]) + coef[parindex+5]*(x-coef[parindex+1])*(x-coef[parindex+1])*(x-coef[parindex+1])				break						case 4:							bkgtemp= coef[parindex+2] + coef[parindex+3]* exp(-(x-coef[parindex+1])/coef[parindex+4])				break			case 5:				bkgtemp= (coef[parindex+2]+coef[parindex+3]*(x-coef[parindex+1])^2) / (exp( (x-coef[parindex+4])/abs(coef[parindex+5]*KB))+1)				break			case 6:				bkgtemp= coef[parindex+3] * area(w_trace, x,coef[parindex+1])+coef[parindex+2]				break			case 7:				bkgtemp = (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)				break				case 8:				 aux0 = 2*sqrt(ln(2))				bkgtemp = coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) 				break			endswitch						if (gv_absbkgflag)				bkgtemp=(bkgtemp<0)?(0):bkgtemp			endif							if (gv_symbkgflag)				bkg+=bkgtemp*1/(exp((x) / (kB*Tbkg))+1.0 )			else				bkg+=bkgtemp			endif					elseif (fnnum>=200)//Peak			fnnum-=200			switch(fnnum)				case 0:						//peak += (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)				// Anti-Lorentzian								// Modified by W. S. Lee				// Change it to an Anti-Lorentizan function with only the energy losss side. Note : The sign was retrofited such that the energy loss is negative in energy and the energy gain side of the spectrum is set to zero.				// Modified by Haiyu Lu				// Change the sign such that the energy loss is positive in energy				peak += abs((x<=0)*((coef[parindex+2]/pi*coef[parindex+3]/2) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4) - (coef[parindex+2]/pi*coef[parindex+3]/2) / ((x+coef[parindex+1])^2+coef[parindex+3]^2/4)))				break					break								case 1:						// Equation: 				// f(x) = A/wG/sqrt(pi/(4*ln(2)))*exp[-4*ln(2)*(x-xc)^2/wG^2]				// xc = coef[parindex+1] 								// A = coef[parindex+2]				// wG = coef[parindex+3]				 						//aux0 = 2*sqrt(ln(2))				//peak += coef[parindex+2]/(coef[parindex+3]*sqrt(pi/(4*ln(2))))*exp(-4*ln(2)*((x-coef[parindex+1])/(coef[parindex+3]))^2) 				//Alternative: at x = xc A corresponds to the amplitude				//coef[parinde+2] is off by a factor of sqrt(wG*Pi*ln(2)/2)				aux0 = 2*sqrt(ln(2))				peak += coef[parindex+2]*exp(-((x-coef[parindex+1])/(coef[parindex+3]/aux0))^2) 				break					case 2: 			   // Lorentzian 			   //f(x) = A*W/2/4/((x-xc)^2+W^2/4)				peak += (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)				break			case 3: 				// Approximation to Voigt profile from IGOR standard fit procedures: Pearson VII				//For shape = 1, this gives a Lorentzian; for the limit shape -> infty, this gives a Gaussian profile				// Equation:	         //f(x) = A / (  1 + (x-x0)^2/shape/W^2)^shape	         // Peak function			   peak += coef[parindex+2] / (1 + (x-coef[parindex+1])^2/coef[parindex+4]/coef[parindex+3]^2)^coef[parindex+4]			   break			case 4: 			   //Pseudo-Voigt: more commonly used than Pearson VII; superposition of Gaussian and Lorentzian			   //Uses independent widths for wG and wL -> for fit, fix wG at resolution of spectrometer			   //Equation: 			   //f(x) = A*[mu*2/pi*wL/(4*(x-xc)^2+wL^2) + (1-mu)*2*sqrt(ln(2))/sqrt(pi)/wG exp[-4*ln(2)/wG^2*(x-xc)^2]]			   	//Define constants 					aux0 = 2*sqrt(ln(2))				//aux1 = sqrt(pi)				//xc = coef[parindex+1]				//AL = coef[parindex+2]				//wL = coef[parindex+3]				//AG = coef[parindex+4]				//wG = coef[parindex+5] 							//Peak function 				//peak += coef[parindex+2]*(coef[parindex+4]*2/pi*coef[parindex+3]/(4*(x-coef[parindex+1])^2+(coef[parindex+3])^2) + (1-coef[parindex+4])*2*sqrt(ln(2))/sqrt(pi)/coef[parindex+5])*exp(-4*ln(2)/(coef[parindex+5])^2*(x-coef[parindex+1])^2)								peak += coef[parindex+2]*(2/pi*coef[parindex+3]/(4*(x-coef[parindex+1])^2+(coef[parindex+3])^2) + (coef[parindex+4])*2*sqrt(ln(2))/sqrt(pi)/coef[parindex+5])*exp(-4*ln(2)/(coef[parindex+5])^2*(x-coef[parindex+1])^2)								break 			//case 4:					// Doniach-Sunjic				// w0: position				// w1: intensity				// w2: gamma							// w3: alpha				//variable ds0 =coef[parindex+2]*cos(pi*coef[parindex+4]/2+(1-coef[parindex+4])*atan((x-coef[parindex+1])/coef[parindex+3])) 	// nominator				//variable ds1 = ((x-coef[parindex+1])^2+coef[parindex+3]^2)^((1-coef[parindex+4])/2)									// denominator				//peak += ds0/ds1				//break			//case 3:				// Fermi-liquid				// requires Fermi-funciton parameters				//checked correct 201801 sdc				//aux0 = coef[parindex+3] +coef[parindex+4]* ((x-coef[parindex+5])^2 + (pi*kB*coef[parindex+6])^2)	// self energy with impurity scattering				//peak += (w[par0+1]*aux0^2/pi) / ((x-w[par0])^2+aux0^2)	// corrected 06-08-04				//peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2)				//break			//case 4:				// marginal Fermi-liquid				// requires Fermi-funciton parameters				//checked correct 201801 sdc				//aux0 = coef[parindex+3] + coef[parindex+4]* pi*0.5*sqrt((x-coef[parindex+5])^2 + (pi*kB*coef[parindex+6])^2) //corrected 2012-12-16		// self energy with impurity scattering				//peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2)				//break			//case 5:				// "empirical FL"				//aux0 = coef[parindex+3] + coef[parindex+4]*x + coef[parindex+5]*x*x				//peak += (coef[parindex+2]*aux0/pi) / ((x-coef[parindex+1])^2+aux0^2/4)				// Lorentzian				//peak += (coef[parindex+2]*coef[parindex+3]^2/4) / ((x-coef[parindex+1])^2+coef[parindex+3]^2/4)				//break	       //case 6:	         //dyne function	         //variable /C E=cmplx(x,0)			  //variable /C Gap=cmplx(coef[parindex+1],0)		     //variable /C GGamma=cmplx(0,coef[parindex+3])			  //peak += abs(coef[parindex+2]*real((E-GGamma)/(sqrt((E-GGamma)*(E-GGamma)-Gap*Gap))))	        //break	       //case 7:	           // SC spectra function	           //if (x==0)  				 //Variable Aw=1/pi/coef[parindex+3]				//else				//Variable SelfEIm=-coef[parindex+3]-coef[parindex+1]^2*coef[parindex+4]/(x^2+coef[parindex+4]^2)				//Variable SelfERe=coef[parindex+1]^2*x/(x^2+coef[parindex+4]^2)				 //Aw=1/pi*SelfEIm/((x-SelfERe)*(x-SelfERe)+SelfEIm*SelfEIm)				//endif				//peak+=-coef[parindex+2]*Aw	          //make /o/n=4 symEDCcof              // symEDCcof=w[par0+p]              // peak += CalsymEDCfit(symEDCcof,x)               //break          // case 8:                 // BCS spectra function             //    Aw=0.5/pi*(coef[parindex+3]/((x-abs(coef[parindex+1]))^2+coef[parindex+3]^2)+coef[parindex+3]/((x+abs(coef[parindex+1]))^2+coef[parindex+3]^2))          //     peak+=coef[parindex+2]*Aw           //    break           //case 8:           		//norman model     			//variable gapsize=coef[parindex+1]			//variable intensity_norman=coef[parindex+2]			//variable gamma1=coef[parindex+3]			//variable gamma0=max(abs(coef[parindex+4]),0.00001)						//variable/C nse = cmplx(0,-gamma1)+gapsize^2/cmplx(x,gamma0)			//variable specfunc=-intensity_norman*imag(nse)/((x-real(nse))^2+(imag(nse))^2)			//peak+=specfunc          // 		break	           endswitch       else		    switch(fnnum)		    case 1: //xfermi		    		fermi = 1/(exp((x-coef[parindex+1]) / (kB*coef[parindex+2]))+1.0 )		    		//gv_Fermiflag=1		    		break 		    case 3://offset		    		offset = coef[parindex+1] + coef[parindex+2] * x + coef[parindex+3]*x*x		    		//gv_offsetflag=1		    		break		    endswitch	   endif				parindex+=FitPar_parnum[index]		index+=1	while (index<numpnts(FitPar_Fnnum))			return offset + (peak + bkg) * fermi	EndFunction ARPES_composed_FitFn(pw, yw, xw): FitFunc	Wave pw, yw, xw		DFREF DF=GetDatafolderDFR()	String DF_panel="root:internalUse:"+winname(0,65)	DFREF DFR_panel=$DF_panel	DFREF DFR_common=$(DF_panel+":panel_common")	DFREF DFR_fit=$(DF_panel+":Fit_data")		Wave FitPar_Fnnum=DFR_panel:FitPar_Fnnum	Wave FitPar_parnum=DFR_panel:FitPar_parnum			NVAR  gv_symbkgflag=DFR_panel:gv_symbkgflag      NVAR gv_absbkgflag=DFR_panel:gv_absbkgflag		WAVE w_trace = DFR_common:w_trace		init_Fit_wave()		NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	//print gv_convolveflag,pw	if (gv_Convolveflag>0)		WAVE w_fit = DFR_panel:w_fit		WAVE /Z w_conv_gauss = DFR_panel:w_conv_gauss		Variable resol=pw[gv_Convolveflag]				if (Waveexists(w_conv_gauss)==0)			init_convolve_Guassin(resol, w_trace) 		endif		WAVE /Z w_conv_gauss = DFR_panel:w_conv_gauss						w_conv_gauss= exp(-x^2*4*ln(2)/resol^2)   		Variable sumGauss = sum(w_conv_gauss, -inf,inf)    		w_conv_gauss /= sumGauss    			w_fit=0		MultiThread w_fit=composed_FitFn(pw,x,w_trace,FitPar_Fnnum,FitPar_parnum,-1,gv_symbkgflag,gv_absbkgflag)		//MultiThread w_fit=composed_FitFn_test(pw,x,-1,DF_panel)		 	Convolve/A w_conv_gauss w_fit 	else				WAVE w_fit = DFR_panel:w_fit		//duplicate /o w_trace DFR_panel:w_fit		w_fit=0		MultiThread w_fit=composed_FitFn(pw,x,w_trace,FitPar_Fnnum,FitPar_parnum,-1,gv_symbkgflag,gv_absbkgflag)		//MultiThread w_fit=composed_FitFn_test(pw,x,-1,DF_panel)	endif 			yw = w_fit(xw[p])	EndFunction init_Fit_wave()	DFREF DF=GetDatafolderDFR()	String DF_panel="root:internalUse:"+winname(0,65)	DFREF DFR_panel=$DF_panel	DFREF DFR_common=$(DF_panel+":panel_common")	//SetActiveSubwindow $winname(0,65)	DFREF DFR_fit=$(DF_panel+":Fit_data")		NVAR gv_Convolveflag=DFR_panel:gv_Convolveflag	Wave CurveFit_coef=DFR_panel:CurveFit_coef		Wave w_trace=DFR_common:w_trace		if (gv_Convolveflag>0)		init_convolve_Guassin(CurveFit_coef[gv_Convolveflag], w_trace)	else		init_disp_fitcurve(DFR_panel,w_trace,"w_fit")	endifEndFunction init_disp_fitcurve(DFR_save,w_trace,peakname)	DFREF DFR_save	Wave w_trace	String peakname		DFREF DF=GetDatafolderDFR()		SetDatafolder DFR_save		variable data_dx, x0, x1		data_dx=deltax(w_trace)	x0=pnt2x(w_trace,0)	x1=pnt2x(w_trace,numpnts(w_trace)-1)		Variable dx = data_dx	// needs to be smaller than the data-width!, not really sure...	Variable y_xfrom = x0 	Variable y_xto = x1				Variable y_pnts = round((y_xto-y_xfrom)/dx)		if (y_pnts<1000)		y_pnts=1000		dx=(y_xto-y_xfrom)/999	endif		Make/o/d/n=(y_pnts) $peakname = 0			SetScale/P x y_xfrom, dx, $peakname		SetDatafolder DFEndFunction init_convolve_Guassin(fwhm, w_trace)	Variable fwhm	Wave w_trace		DFREF DF=GetDatafolderDFR()	String DF_panel="root:internalUse:"+winname(0,65)	DFREF DFR_panel=$DF_panel	DFREF DFR_common=$(DF_panel+":panel_common")	//SetActiveSubwindow $winname(0,65)	DFREF DFR_fit=$(DF_panel+":Fit_data")		SetDatafolder DFR_panel		 	variable data_dx, x0, x1				data_dx=deltax(w_trace)	x0=pnt2x(w_trace,0)	x1=pnt2x(w_trace,numpnts(w_trace)-1)		 			Variable res=10			if (fwhm == 0 || numtype(fwhm) != 0)			fwhm = 0.002		else			fwhm =  abs(fwhm)		endif		Variable gauss_from = 10 * fwhm		Variable dx =  min(fwhm/res, abs(data_dx/5))		// needs to be smaller than the data-width!, not really sure...		Variable y_xfrom = x0 - 4 * fwhm		Variable y_xto = x1 + 4 * fwhm				Variable gauss_pnts = round(gauss_from/dx) * 2 + 1		Variable y_pnts = round((y_xto-y_xfrom)/dx)				Make/o/d/n=(gauss_pnts) w_conv_gauss = 0		Make/o/d/n=(y_pnts) w_fit = 0				SetScale/P x y_xfrom, dx, w_fit		SetScale/P x -gauss_from, dx, w_conv_gauss	SetDatafolder DFEnd	Function init_conv_composed_FF(fwhm, res, data_dx, x0, x1)	Variable fwhm, res, data_dx, x0, x1		String DF = GetDataFolder (1)	SetDataFolder root:internalUse:fit					if (fwhm == 0 || numtype(fwhm) != 0)			fwhm = 0.002		else			fwhm =  abs(fwhm)		endif		Variable gauss_from = 10 * fwhm		Variable dx =  min(fwhm/res, abs(data_dx/2))		// needs to be smaller than the data-width!, not really sure...		Variable y_xfrom = x0 - 4 * fwhm		Variable y_xto = x1 + 4 * fwhm				Variable gauss_pnts = round(gauss_from/dx) * 2 + 1		Variable y_pnts = round((y_xto-y_xfrom)/dx)				Make/o/d/n=(gauss_pnts) w_conv_gauss = 0		Make/o/d/n=(y_pnts) w_conv_y = 0				SetScale/P x y_xfrom, dx, w_conv_y		SetScale/P x -gauss_from, dx, w_conv_gauss			SetDataFolder $DFEnd