#pragma rtGlobals=1		// Use modern global access method#pragma version = 0.01Function m_Cut(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	// value of variable as number	String varStr		// value of variable as string	String varName	// name of variable		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	String DF_common="root:internalUse:"+panelName+":panel_common"	DFREF DFR_common=$DF_common	DFREF DFR_panel=$DF_panel	SetActiveSubwindow $winname(0,65)	NVAR first =DFR_panel:gv_first	NVAR last = DFR_panel:gv_last	NVAR step = DFR_panel:gv_step	NVAR DCnum= DFR_panel:gv_DCnum	NVAR col=DFR_panel:gv_col	WAVE w_image = DFR_common:w_image		ControlInfo DCs_c0	Variable dim_flag=v_value    	if (stringmatch(ctrlname,"DCs_sv0")||stringmatch(ctrlname,"DCs_sv1")) //first and last		if (dim_flag)		Cursor/P/I/H=1 A w_image first,qcsr(A)		Cursor/P/I/H=1 B w_image last,qcsr(B)		else		Cursor/P/I/H=1 A w_image pcsr(A),first		Cursor/P/I/H=1 B w_image pcsr(B),last		endif	return 1	endif		if (stringmatch(ctrlname,"DCs_sv2")||stringmatch(ctrlname,"DCs_sv15"))		Cursor/P/I/H=1 A w_image pcsr(A),qcsr(A)		Cursor/P/I/H=1 B w_image pcsr(B),qcsr(B)		col=abs(step)	return 1	endif	EndFunction all_DC(ctrlName)	String ctrlName		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	String DF_common="root:internalUse:"+panelName+":panel_common"	DFREF DFR_common=$DF_common	DFREF DFR_panel=$DF_panel	SetActiveSubwindow $winname(0,65)	NVAR first =DFR_panel:gv_first	NVAR last = DFR_panel:gv_last	NVAR step = DFR_panel:gv_step	NVAR DCnum= DFR_panel:gv_DCnum	WAVE w_image = DFR_common:w_image		ControlInfo DCs_c0	Variable dimflag=v_value		first = 0	if (dimflag==0)	last=dimsize(w_image,1)-1	step=dimsize(w_image,1)	Cursor/P/I/H=1 A w_image pcsr(A),first	Cursor/P/I/H=1 B w_image pcsr(B),last	else	last=dimsize(w_image,0)-1	step=dimsize(w_image,0)	Cursor/P/I/H=1 A w_image first,qcsr(A)    Cursor/P/I/H=1 B w_image last,qcsr(B)	endif	collapse_Proc("all",1)	ControlUpdate DCs_sv0	ControlUpdate DCs_sv1	ControlUpdate DCs_sv2    ControlUpdate DCs_sv15    ControlUpdate DCs_sv16EndFunction Align_DC(ctrlName)	String ctrlName		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	String DF_common="root:internalUse:"+panelName+":panel_common"	DFREF DFR_common=$DF_common	DFREF DFR_panel=$DF_panel	SetActiveSubwindow $winname(0,65)	NVAR first =DFR_panel:gv_first	NVAR last = DFR_panel:gv_last	NVAR step = DFR_panel:gv_step	NVAR DCnum= DFR_panel:gv_DCnum	NVAR csrstep=DFR_panel:gv_csrstepnum	WAVE w_image = DFR_common:w_image	Wave n_mdc=DFR_common:n_mdc	Wave n_edc=DFR_common:n_edc		ControlInfo DCs_c0	Variable dimflag=v_value		Variable setpoint	StrSwitch (ctrlname)	case  "DCs_b25":  //all aline	Cursor/P/I/H=1 A w_image pcsr(B),qcsr(B)	break	case "DCs_b21":// green	DCnum=1 	if(dimflag)		setpoint=pcsr(B)		Cursor/P/I/H=1 A w_image trunc(setpoint-(csrstep-1)/2),qcsr(A)	    Cursor/P/I/H=1 B w_image trunc(setpoint-(csrstep-1)/2)+csrstep-1,qcsr(B)	    else	    setpoint=qcsr(B)	       Cursor/P/I/H=1 A w_image pcsr(A),trunc(setpoint-(csrstep-1)/2)	       Cursor/P/I/H=1 B w_image pcsr(B),trunc(setpoint-(csrstep-1)/2)+csrstep-1	    endif	break	case "DCs_b23"://red	DCnum=1	 if(dimflag)	 	setpoint=pcsr(A)	      Cursor/P/I/H=1 B w_image trunc(setpoint-(csrstep-1)/2)+csrstep-1,qcsr(B)	      Cursor/P/I/H=1 A w_image trunc(setpoint-(csrstep-1)/2),qcsr(A)	   else	   setpoint=qcsr(B)	      Cursor/P/I/H=1 B w_image pcsr(B),trunc(setpoint-(csrstep-1)/2)+csrstep-1	      Cursor/P/I/H=1 A w_image pcsr(A),trunc(setpoint-(csrstep-1)/2)	  endif	break		endswitch	collapse_Proc("Align",1)	ControlUpdate DCs_sv0	ControlUpdate DCs_sv1	ControlUpdate DCs_sv2	ControlUpdate DCs_sv15	ControlUpdate DCs_sv16EndFunction red_and_green_DC(ctrlName)	String ctrlName		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	String DF_common="root:internalUse:"+panelName+":panel_common"	DFREF DFR_common=$DF_common	DFREF DFR_panel=$DF_panel	SetActiveSubwindow $winname(0,65)	NVAR first =DFR_panel:gv_first	NVAR last = DFR_panel:gv_last	NVAR step = DFR_panel:gv_step	NVAR DCnum= DFR_panel:gv_DCnum	NVAR col= DFR_panel:gv_col	WAVE w_image = DFR_common:w_image		Variable pg,pr	controlinfo DCs_c0	if (v_value)	pg=pcsr(B)	pr=pcsr(A)	else	pr=qcsr(A)	pg=qcsr(B)	endif		if (stringmatch(ctrlName,"DCs_b24")) 		DCnum=1		first=pr		last=pr		step=1		col=1	endif		if (stringmatch(ctrlName,"DCs_b26")) 		DCnum=1		last=pg		first=pg		step=1		col=1	endif		if (stringmatch(ctrlName,"DCs_b22")) //R+G		DCnum=1		Cursor/P/I/H=1 A w_image pcsr(A),qcsr(A)        Cursor/P/I/H=1 B w_image pcsr(B),qcsr(B)	endif		if (stringmatch(ctrlName,"DCs_b27")) //default		DCnum=20		Cursor/P/I/H=1 A w_image pcsr(A),qcsr(A)        Cursor/P/I/H=1 B w_image pcsr(B),qcsr(B)	endif		if (stringmatch(ctrlName,"DCs_b42")) //Single		DCnum=abs(pg-pr)+1		Cursor/P/I/H=1 A w_image pcsr(A),qcsr(A)        Cursor/P/I/H=1 B w_image pcsr(B),qcsr(B)	endif		ControlUpdate DCs_sv0	ControlUpdate DCs_sv1	ControlUpdate DCs_sv2	ControlUpdate DCs_sv15	ControlUpdate DCs_sv16		End	Function slider_offset(name, value, event)	String name			// name of this slider control	Variable value		// value of slider	Variable event		// bit field: bit 0: value set; 1: mouse down, 2: mouse up, 3: mouse moved	DFREF Df= GetDatafolderDFR()	String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	SetActiveSubwindow $winname(0,65)	DFREF DFR_panel=$DF_panel		NVAR x_offset = DFR_panel:gv_x_offset	NVAR y_offset = DFR_panel:gv_y_offset		ControlUpdate DCs_sv3	ControlUpdate DCs_sv4		String gN = WinName(1,1)	if (strlen(gN) == 0)		return -1	endif	if (stringmatch(gN,"*panel*"))		return -1	endif	String List = TraceNameList(gN, ";",1)		if (strlen(list)==0)		SetDatafolder DF		return 0	endif		String TraceName,WaveN0,WaveN1	Variable lookup	Variable items = ItemsInList(List,";")	Variable default_y_offset=0, default_x_offset=0	Variable from, to, comp, from0, num_off,num0	String str0, str1		Variable index = 0	do		TraceName = StringFromList(index,List)				WAVE temp = TraceNameToWaveRef(gN, TraceName)		duplicate /o/Free temp temp_abs		temp_abs=abs(temp)		WaveStats/Q temp_abs		if (numtype(v_avg)==0)			default_y_offset=(v_avg>default_y_offset)?(v_avg):(default_y_offset)		endif	index += 1	while (index < items)						default_y_offset = default_y_offset	default_x_offset = numpnts(temp)*deltax(temp)/10	// offset the traces	Variable delta_y = y_offset * default_Y_offset	Variable delta_x = x_offset * default_x_offset    	controlinfo DCs_offck0	Variable c_none=v_value	controlinfo DCs_offck1	Variable c_wn=v_value	controlinfo DCs_offck2	Variable c_dc=v_value		if (c_none) //none		index = 0		do				TraceName = StringFromList(index,List)			ModifyGraph/w=$gn offset($TraceName)={delta_x*(index),delta_y*(index)}			index += 1		while (index < items)		SetDatafolder DF		return 0	endif		if (c_wn) //wavename		TraceName = StringFromList(0,List)		from = Strsearch(Tracename, "_e", inf,1)		if (from == -1)			from = Strsearch(Tracename, "_m", inf,1)			if (from == -1)					from = inf			endif		endif		WaveN0=TraceName[0,(from-1)]		index = 0		Variable offindex=0		do				TraceName = StringFromList(index,List)					from = Strsearch(Tracename, "_e", inf,1)			if (from == -1)				from = Strsearch(Tracename, "_m", inf,1)				if (from == -1)					from = inf				endif			endif			WaveN1=TraceName[0,(from-1)]			if (stringmatch(WaveN0,WaveN1)==0)				offindex=0				WaveN0=WaveN1			endif		ModifyGraph/w=$gn offset($TraceName)={delta_x*(offindex),delta_y*(offindex)}				offindex+=1		index += 1		while (index < items)		SetDatafolder DF		return 0	endif		if (c_dc) //DCs		TraceName = StringFromList(0,List)	from = Strsearch(Tracename, "_e", inf,1)	if (from == -1)		from = Strsearch(Tracename, "_m", inf,1)		if (from == -1)			doalert 0,"Error DCs in the Graph!"			return 0		else		lookup=0		endif	else		lookup=1	endif	from0=from	from = Strsearch(Tracename, "_", (from0+3),0)	num0=str2num(Tracename[(from0+4),(from-1)])		index = 1	Variable nummax=0,nummin=10000,numdelta=10000	do		TraceName = StringFromList(index,List)		if (lookup)			from= Strsearch(Tracename, "_e", inf,1)		else			from = Strsearch(Tracename, "_m", inf,1)		endif		from0=from		from = Strsearch(Tracename, "_", (from0+3),0)		num_off=str2num(Tracename[(from0+4),(from-1)])	 		if (numtype(num_off)==0)			nummax=(num_off>nummax)?(num_off):(nummax)			nummin=(num_off<nummin)?(num_off):(nummin)			numdelta=(abs(num_off-num0)<numdelta)?(abs(num_off-num0)):(numdelta)			num0=num_off		else			doalert 0,"Error DCs in the Graph!"			return 0		endif			index += 1	while (index < items)			index = 0	offindex=0	do			TraceName = StringFromList(index,List)				if (lookup)		from= Strsearch(Tracename, "_e", inf,1)		else		from = Strsearch(Tracename, "_m", inf,1)		endif		from0=from		from = Strsearch(Tracename, "_", (from0+3),0)		num_off=str2num(Tracename[(from0+4),(from-1)])				offindex=(num_off-nummin)/numdelta			ModifyGraph/w=$gn offset($TraceName)={delta_x*(offindex),delta_y*(offindex)}	index += 1	while (index < items)	SetDatafolder DF	return 0	endif		EndFunction sv_offset(ctrlName,varNum,varStr,varName)	String ctrlName	Variable varNum	String varStr	String varName		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	DFREF DFR_panel=$DF_panel	SetActiveSubwindow $winname(0,65)		NVAR x_offset = DFR_panel:gv_x_offset	NVAR y_offset = DFR_panel:gv_y_offset			ControlInfo DCs_sv3	x_offset = v_value	ControlInfo DCs_sv4	y_offset = v_value		//ControlUpdate DCs_sl0	//ControlUpdate DCs_sl1	Slider DCs_sl1, value=y_offset	Slider DCs_sl0, value=x_offset	slider_offset("dum", NaN, 1)End//--------------------------------- extract and display DC's --------------------------------------Function display_DC(ctrlname): buttonControl	String ctrlname	//ControlInfo DCpopup11	display_DCs(0,0)		// displayEndFunction add_DC(ctrlname): buttonControl	String ctrlname	//ControlInfo DCpopup11	display_DCs(1,0)		// addEndFunction remove_DC(ctrlname): buttonControl	String ctrlname	//ControlInfo DCpopup11	display_DCs(2,0)		// removeEnd//////////////////////////////////////////////////////////////////////////////////////////////////////////// Function display_DCs(d_flag,i_flag)							Variable d_flag, i_flag	DFREF DF = GetDataFolderDFR()		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	String DFS_common="root:internalUse:"+panelName+":panel_common"	DFREF DF_common=$DFS_common	DFREF DFR_panel=$DF_panel	SetActiveSubwindow $winname(0,65)	NVAR first =DFR_panel:gv_first	NVAR last = DFR_panel:gv_last	NVAR step = DFR_panel:gv_step	NVAR DCnum= DFR_panel:gv_DCnum	NVAR colstep=DFR_panel:gv_col				SVAR sourcePathlist=DF_common:gs_sourcePathlist	SVAR sourcenamelist=DF_common:gs_sourcenamelist	SVAR toppath=DF_common:gs_TopItemPath	SVAR topName = DF_common:gs_TopItemName	NVAR toplayernum=DF_common:gv_toplayernum	NVAR topwaverow=DF_common:gv_topwaverow	NVAR topdfrow=DF_common:gv_topdfrow	WAVE/t w_DF=DF_common:w_DF	WAVE/t w_sourceNames=DF_common:w_sourceNames	Wave/b w_sourceNamesSel=DF_common:w_sourceNamesSel		NVAR autoDCflag=DFR_panel:gv_autoDCflag		String suffix, cmd0, cmd1	String DCname, Mname, StrIndex	String noteStr,DCnote,mnote	String Path,gN		Variable index,n,i,aux0,aux1,aux2	Variable w_points, scalefrom, scaleto			ControlInfo DCs_c0		Variable dim = v_value			// dimension (1=EDC, 0=MDC)	Variable dim2 = abs(dim-1)	// dimension (0=EDC, 1=MDC)	Variable plotlayernum	if (d_flag!=0)	    gN=WinName(1,1)	    if ((strlen(gN)==0)||(stringmatch(gN,"*panel*")))	    	SetDatafolder DF	    	return 0	    else	    	doWindow/F $gN	    endif	else		Display  /K=1/W= (10, 10, 280,320)		gN=WinName(0,1)	    	doWindow/F $gN	   	 if (dim)	    		gN=uniquename("EDC_",6,0)	    	else	    		gN=uniquename("MDC_",6,0)	    	endif	   	 Dowindow /C $gN	   	 SetWindow $gN, hook(MyHook) = MygraphHook	    	endif		Attachtobottom(winname(1,65),gN,3)		if (dim)		newDatafolder /o/s $("root:graphsave:EDCs:"+gN)	else		newDatafolder /o/s $("root:graphsave:MDCs:"+gN)	endif   	Variable Windex,datalayernum,procdone,WaveSum	String wave_path,wave_name	Variable tempsel		Check_Autosimilar_layer(DF_common,1)		do		if ((w_sourceNamesSel[Windex] == 1)||(w_sourceNamesSel[Windex] == 8)||(w_sourceNamesSel[Windex] == 9))			toppath=w_DF[topdfrow]+w_sourceNames[Windex]			topname=w_sourceNames[Windex]			tempsel=w_sourceNamesSel[Windex]			w_sourceNamesSel[Windex]=0			WaveSum+=1				if (strlen(toppath)==0)				break			endif			wave_path=toppath				Wave data=$wave_path					if (wavedims(data)>2)				GetProList(DF_common,data,nan)				plotlayernum=toplayernum			else				plotlayernum=0			endif				if (autoDCflag)				Dowindow /F $panelname					Panelimageupdate(3)			endif			GetLayerimage(data,plotlayernum)			duplicate /o templayerimage,tempimage			killwaves/Z templayerimage				Wave W = tempimage			notestr = note(data)			notestr= Getlayernotestr(notestr,plotlayernum,0)						DCnote = ""				String procname=GetLayerprocname(data,plotlayernum)						Mname = NameofWave(data)						if (strlen(Mname)>8)			    	variable from=strsearch(Mname, "_", inf ,1)			    	Mname += "_"//+Mname[strlen(Mname)-5,strlen(Mname)-1]			  endif				if (dim == 1)	// EDC				suffix = "_e"				scalefrom = M_y0(w)				scaleto = M_y1(w)			else				// MDC				suffix = "_m"				scalefrom = M_x0(w)				scaleto = M_x1(w)			endif			// make and scale the DC				w_points = Dimsize(w,dim)			Make/O/N=(w_points) t_DC=0			SetScale/I x scalefrom, scaleto,"", t_DC	  		 	dowindow /F $gN      			index = 0  			do				n = first+index*step				t_DC=0				aux0 = dimoffset(w,dim2) + n * dimdelta(w,dim2)				aux1= dimoffset(w,dim2) + (n+step/abs(step)*(colstep-1))* dimdelta(w,dim2)				aux2 = (2*dimoffset(w,dim2) + (2*n+(step/abs(step)*(colstep-1)))* dimdelta(w,dim2))/2						if (dim == 1)	// EDC							for(i=0;i<colstep;i+=1)		 				if (step<0) 							 t_DC+=w[n-i][p] 						 else							 t_DC+=w[n+i][p] 						 endif 					endfor               					t_DC/=colstep  			    					    					DCname = Mname + procname[0,2]+suffix+ "_f"+num2indstr(n,3)+"_t"+num2indstr(n+(step/abs(step)*(colstep-1)),3)								DCnote = Notestr+"\rEnergy Distribution Curve\r"					DCnote +="SourceCarpet="+wave_path+"\r"					DCnote +="MomentumFrom="+num2str(aux0)+"\r"+"MomentumTo="+num2str(aux1)+"\r"+"Momentum="+num2str(aux2)+"\r"					sprintf mnote, "kx=%g\rky=%g\rkz=%g\r",0,0,0	      				DCnote+=mnote								else		// MDC			    				for(i=0;i<colstep;i+=1)				 		if (step<0) 							 t_DC+=w[p][n-i]						else		 					t_DC+=w[p][n+i]		 				endif 	    				endfor               	    				t_DC/=colstep  	   	   				DCname = Mname + procname[0,2]+suffix +"_f"+num2indstr(n,3)+"_t"+num2indstr(n+(step/abs(step)*(colstep-1)),3)					DCnote =Notestr+ "\rMomentum Distribution Curve\r"					DCnote +="SourceCarpet="+wave_path+"\r"					DCnote += "EnergyFrom="+num2str(aux0)+"\r"+"EnergyTo="+num2str(aux1)+"\r"+"Energy="+num2str(aux2)+"\r"		   			endif						DCname=checkwavename(DCname,0)				DCnote=replacestringbykey("WaveName",DCnote,DCname,"=","\r")						Duplicate/O t_DC $DCName				Note/K $DCName				Note $DCName, DCnote										if (d_flag == 0)					AppendToGraph $DCName					//	ModifyGraph/Z lSize($DCname) = 0.5					//	ModifyGraph rgb($DCname)=(0,0,0)				elseif (d_flag == 1)					AppendToGraph/W=$gN  $DCName					//	ModifyGraph/Z lSize($DCname) = 0.5					//	ModifyGraph rgb($DCname)=(65535,0,0)				else					String trlist=TraceNameList(gN,";",1)					if (strsearch(trlist,DCname,0)==-1)						DCname=stringFromList((itemsinlist(trlist,";")-1),trlist,";")					endif 					RemoveFromGraph/W=$gN /Z $DCName				endif								// offsetting this way round makes filling easier						index += 1			while (index < DCnum)				w_sourceNamesSel[Windex]=tempsel		endif			if (wavesum==itemsinlist(sourcePathlist))			break		endif					Windex+=1	while (Windex<numpnts(w_sourceNamesSel))	//	Killwaves /Z w	dowindow /F $panelname		DC_Style(gN,dim)		slider_offset("dum", NaN, 1)		killwaves/Z  tempimage		toppath=w_DF[topdfrow]+w_sourceNames[topwaverow]	topname=w_sourceNames[topwaverow]		Wave data=$toppath		GetProList(DF_common,data,NAN)	panelimageupdate(3)			KillWaves/Z t_DC	SetDataFolder DFEndFunction/C EstPeakNoiseAndSmfact(w,pBegin,pEnd)	Wave w	Variable pBegin,pEnd		if (abs(pBegin-pEnd) < 10)			// 10 is pretty arbitrary; this is intended to avoid trying to apply this test to unreasonably small waves. Even a 10-point wave is probably a mistake: a fit coefficient wave was selected by mistake or something.		return cmplx(0,0)	endif			if( pBegin > pEnd )		Variable tmp= pBegin		pBegin= pEnd		pEnd= tmp	endif		NewDataFolder/S/O afpTemp	Duplicate/O/R=[pBegin,pEnd] w,wtmp	Differentiate wtmp	Duplicate/O wtmp, wtmpOrigDif	Make/O/N=1000 hist	Histogram/B=1 wtmp,hist	Integrate hist	FindLevel/Q hist,0.4*hist[999]	Variable x0= V_LevelX	FindLevel/Q hist,0.6*hist[999]	Variable x1= V_LevelX	Variable noiselevel= abs(2*(x1-x0)*deltax(w))	Variable snr=(pnt2x(hist, 999)-pnt2x(hist, 0))/(x1-x0)		if( pEnd>=numpnts(w) )		pEnd= numpnts(w)-1	endif	if( pBegin<0 )		pBegin= 0	endif	Variable maxSfact= (pEnd-pBegin+1)/20	Variable nMaxSF=2* ceil(sqrt(maxSfact))	Make/O/N=(nMaxSF) wsmdata=0,wsmFact= round((P/2)^2)	Variable nLin=10	Variable nSpaced=20	//print maxSfact	if( maxSfact<20 )		nSpaced= 0		nLin= maxSfact	endif	nMaxSF= nLin+nSpaced	Variable a= (maxSfact-nLin)/nSpaced^2	Make/O/N=(nMaxSF) wsmdata=0,wsmFact= p+1	if( nSpaced>0 )		wsmFact[nLin,*]= ceil(nLin+a*(p-nLin+1)^2)	endif	Variable i=1,imax= min(nMaxSF, numpnts(wsmFact))	wsmdata[0]= snr	do		Duplicate/O wtmpOrigDif,wtmp		Smooth/E=2/B=3 2*wsmFact[i]+1, wtmp		Histogram/B=1 wtmp,hist		Integrate hist		FindLevel/Q hist,0.4*hist[999]		x0= V_LevelX		FindLevel/Q hist,0.6*hist[999]		x1= V_LevelX		snr= (pnt2x(hist, 999)-pnt2x(hist, 0))/(x1-x0)		wsmdata[i]= snr		i+=1	while(i<imax)//Duplicate/O wsmdata, root:snrData//Duplicate/O wsmFact, root:smoothFactors	WaveStats/Q/R=[2,] wsmdata	Variable smFact= wsmFact[V_maxloc]	// added heuristics//	Variable smFactwpd=0	do		if( wsmdata[V_maxloc] < 100 )			Variable didIt=0			i=0			do				Variable findPeaksReturn = AutoFindPeaks(w,pBegin,pEnd,noiselevel*10,wsmFact[i],1)//				Variable findPeaksReturnOriginal = AutoFindPeaksOriginal(w,pBegin,pEnd,noiselevel*10,wsmFact[i],1)//				Variable findPeaksReturnNew = AutoFindPeaksNew(w,pBegin,pEnd,noiselevel*10,wsmFact[i],1)//print "Smooth Factor:", wsmFact[i], "Original:", findPeaksReturnOriginal, "New:", findPeaksReturnNew//				if( findPeaksReturnOriginal > 0 )//				if( findPeaksReturnNew > 0 )				if( findPeaksReturn > 0 )					Wave wpd= W_AutoPeakInfo//					smFactwpd= floor(wpd[0][1]/3)					smFact= round(wpd[0][1]/3)					didIt= 1//	print "TRIAL FIND",wpd[0][1],smFact,i,wsmFact[i],wsmdata[V_maxloc],wsmdata[i]					break;				endif				i+=1			while(i<imax)			if( didIt )				break			endif		endif		// If really low snr and couldn't find a principal peak, force high smooth factors		if( wsmdata[V_maxloc] < 20 )			smFact= maxSfact			break		endif		if( wsmdata[V_maxloc] < 30 )			smFact= round(maxSfact/4)			break		endif		if( wsmdata[V_maxloc] < 50 )			smFact= round(maxSfact/6)			break		endif	while(0)	if( smFact < 2 )		smFact= 2	endif	//	smFact = max(smFact, smFactwpd)	KillDataFolder ://SetDataFolder ::	return cmplx(noiselevel,smFact)endFunction AutoFindPeaks(w,pBegin,pEnd,noiseEst,smFact,maxPeaks)	Wave w	Variable pBegin,pEnd	Variable noiseEst,smFact	Variable maxPeaks	print "function to be developed"//	NVAR/Z doOriginal = root:V_PeakAutoFindClassic//	if ( (!NVAR_Exists(doOriginal)) || (doOriginal == 0) )//		return AutoFindPeaksNew(w,pBegin,pEnd,noiseEst,smFact,maxPeaks)//	else//		return AutoFindPeaksOriginal(w,pBegin,pEnd,noiseEst,smFact,maxPeaks)//	endif//end////static constant numPeakInfoColumns = 5		// JW 071031//Function AutoFindPeaksOriginal(w,pBegin,pEnd,noiseEst,smFact,maxPeaks)//	Wave w//	Variable pBegin,pEnd//	Variable noiseEst,smFact//	Variable maxPeaks//	//	if( pBegin > pEnd )//		Variable tmp= pBegin//		pBegin= pEnd//		pEnd= tmp//	endif//	//	Make/O/N=(0,numPeakInfoColumns) W_AutoPeakInfo//	//	NewDataFolder/S/O afpTemp2//	Duplicate/O/R=[pBegin,pEnd] w,wtmp1//	SetScale/P x,0,1,wtmp1					// we work in point numbers here//////	Duplicate/O wtmp1,wtmp2//	Smooth/B=3 smFact, wtmp1				// for peak amp determination//	////Duplicate/O wtmp1, root:smooth1////	Duplicate/O wtmp1,wtmp2////Duplicate/O wtmp1, root:debugDif////	Differentiate wtmp2//	Smooth/E=2/B=3 2*smFact, wtmp2////Duplicate/O wtmp2, root:difsmooth2//	Differentiate wtmp2//	Smooth/E=2/B=3 2*smFact, wtmp2////Duplicate/O wtmp2, root:dif2smooth3//	Duplicate/O wtmp2,wtmp3				// we mung one copy and need an unmunged version also//	//	Variable avgWidth=0					// for width not too far from average width criteria//	//	Variable i=0,peakNum=0,numBadPeaks=0//	do//		WaveStats/Q wtmp2//		Variable x0= V_minloc		// really, need to determine if + or - peaks and use right one////		if( V_min>=0 )//			break//		endif////		FindLevel/Q/R=[x0,] wtmp3,0//		Variable xr= V_LevelX//		if( V_Flag!=0 )//			xr= numpnts(wtmp3)-1//		endif//		FindLevel/Q/R=[x0,0] wtmp3,0		// note search is from right to left//		Variable xl= V_LevelX//		if( V_Flag!=0 )//			xl= 0//		endif//		wtmp2[xl-1,xr+1]=NaN						// don't find this peak again////		Variable widthEst//		Variable rightWidthEst, leftWidthEst, leftWidthFraction	// JW 071031//		do//			if( (x0-xl) < 1 )//				widthEst= xr-x0				// if up against the left edge, use right width//				break//			endif//			if( (xr-x0) < 1 )//				widthEst= x0-xl				// similar for right edge//				break//			endif//			Variable ratio= (xr-x0)/ (x0-xl)	// right width/left width//			if( (ratio < 0.5) || (ratio>2) )//				widthEst=2* min(xr-x0, x0-xl)	// take smaller of widths if one is much larger//				break//			endif//			widthEst= xr-xl//		while(0)////		rightWidthEst = xr-x0						// JW 071031//		leftWidthEst = x0-xl						// JW 071031//		leftWidthFraction = leftWidthEst/widthEst	// JW 071031//		//		if( !(widthEst>3) )						// this probably will neverhappen but if it did, we are probably out of real peaks//			break//		endif////		Variable impulseWidth= 2*(2*smFact+1)//		if( widthEst > 1.3*impulseWidth )//			widthEst= sqrt(widthEst^2 - impulseWidth^2)//		else//			widthEst= widthEst/2//		endif//		leftWidthEst = widthEst*leftWidthFraction//		rightWidthEst = widthEst - leftWidthEst//		//		Variable yl= wtmp1[xl], y0= wtmp1[x0], yr= wtmp1[xr]//		Variable bl0= ((yr-yl)/(xr-xl)*(x0-xl)+yl		// y at x0 for line between left and right inflection points//		//		Variable heightEst= 2*(y0-bl0)//		//		Variable avgNoiseEst= noiseEst/(1.35*sqrt(2*smFact+1))//		Variable minH= avgNoiseEst*8//		//		// throw in an additional penalty if width is far away from the average//		if( avgWidth>0 )//			minH *= sqrt( (widthEst/avgWidth)^2 + (avgWidth/widthEst)^2 )//		endif//		if( heightEst >  minH )//			Redimension/N=(peakNum+1,numPeakInfoColumns) W_AutoPeakInfo//			avgWidth= (avgWidth*peakNum+widthEst)/(peakNum+1)//			W_AutoPeakInfo[peakNum]={{x0+pBegin},{widthEst},{heightEst},{leftWidthEst},{rightWidthEst}}//			peakNum+=1//		else//			if( peakNum == 0 )//				break					// if very first peak is bad, then give up//			endif//			numBadPeaks += 1//			if( numBadPeaks > 3 )//				break//			endif//		endif//	while(peakNum<maxPeaks)//	KillDataFolder :////	return 	peakNumreturn 0end// The AutoFindPeaks functions make a temporary data folder and then kill it. This function depends on that to get rid of some temporary waves.Function findPeaksIn2ndDeriv(win)	Wave win		Make/N=(100,7)/O results	Variable startP = 0	Variable numPeak=0	Variable lowBad = 0	Variable highBad = 0	findpeak/B=1/N/P/R=[startP,]/Q win	results[numPeak][0]=V_PeakLoc	results[numPeak][1]=V_PeakVal	if (V_flag)		// couldn't find even one low point???		Redimension/N=0 results		return -1	endif	findpeak/B=1/P/R=[V_PeakLoc,0]/Q win	results[numPeak][2]=V_PeakLoc	results[numPeak][3]=V_PeakVal	if (V_flag)		lowBad = 1	endif	findpeak/B=1/P/R=[results[numPeak][0],]/Q win	results[numPeak][4]=V_PeakLoc	results[numPeak][5]=V_PeakVal	if (V_flag)		// Couldn't find the other side of the first peak		Redimension/N=0 results		return -1	endif	if (lowBad)		startP = V_PeakLoc	endif		Variable leftPeakLoc, leftPeakVal	Variable midPeakLoc, midPeakVal	Variable rightPeakLoc, rightPeakVal	do		findpeak/B=1/N/P/R=[startP,]/Q win		midPeakLoc=V_PeakLoc		midPeakVal=V_PeakVal		if (V_flag)			break;		endif		findpeak/B=1/P/R=[V_PeakLoc,0]/Q win		leftPeakLoc=V_PeakLoc		leftPeakVal=V_PeakVal		if (V_flag)			break;		endif		findpeak/B=1/P/R=[midPeakLoc,]/Q win		rightPeakLoc=V_PeakLoc		rightPeakVal=V_PeakVal		if (V_flag)			break;		endif				results[numPeak][0]=midPeakLoc		results[numPeak][1]=midPeakVal		results[numPeak][2]=leftPeakLoc		results[numPeak][3]=leftPeakVal		results[numPeak][4]=rightPeakLoc		results[numPeak][5]=rightPeakVal		results[numPeak][6]=min(abs(midPeakVal - leftPeakVal), abs(midPeakVal - rightPeakVal))			startP=V_PeakLoc		numPeak += 1		if (numPeak >= DimSize(results, 0))			Redimension/N=(numPeak+100, -1) results		endif	while(1)		Redimension/N=(numPeak, -1) results	Make/O/N=(numPeak) sortwave	sortwave = results[p][6]	MakeIndex/R sortwave, sortwave	Duplicate/O results, resultscopy//Duplicate/O results, root:resultscopy//Wave resultscopy = root:resultscopy	results = resultscopy[sortwave[p]][q]//Duplicate/O results, root:resultsSortedend// for debugging//Function PutLinesOnGraph(win, graph, numpeaks)//	Wave win//	String Graph//	Variable numpeaks//	//	Variable numRows = DimSize(win, 0)//	Variable i//	//	SetDrawLayer/W=$Graph/K progBack//	for (i = 0; i < numpeaks; i += 1)//		SetDrawEnv/W=$Graph fillfgc=(50000,50000,50000),linethick=1,ycoord=prel,xcoord=bottom//		DrawRect/W=$Graph win[i][2], 1-i*.01, win[i][4], 0+(numpeaks-i)*.01//		SetDrawEnv/W=$Graph linefgc=(30000,30000,30000),ycoord=prel,xcoord=bottom//		DrawLine/W=$Graph win[i][0], 0, win[i][0], 1//		SetDrawEnv/W=$Graph textxjust=1,ycoord=prel,xcoord=bottom//		DrawText/W=$Graph win[i][0], 1-i*.01, num2str(i)//	endfor//endFunction AutoFindPeaksNew(w,pBegin,pEnd,noiseEst,smFact,maxPeaks)	Wave w	Variable pBegin,pEnd	Variable noiseEst,smFact	Variable maxPeaks	print "function to be developed"//	//	if( pBegin > pEnd )//		Variable tmp= pBegin//		pBegin= pEnd//		pEnd= tmp//	endif//	//	Make/O/N=(0,numPeakInfoColumns) W_AutoPeakInfo//	//	NewDataFolder/S/O afpTemp2//	Duplicate/O/R=[pBegin,pEnd] w,wtmp1//	SetScale/P x,0,1,wtmp1					// we work in point numbers here////	Smooth/B=3 smFact, wtmp1				// for peak amp determination//	////Duplicate/O wtmp1, root:smooth1////	Duplicate/O wtmp1,wtmp2////Duplicate/O wtmp1, root:debugDif////	Differentiate wtmp2//	Smooth/E=2/B=3 2*smFact, wtmp2////Duplicate/O wtmp2, root:difsmooth2//	Differentiate wtmp2//	Smooth/E=2/B=3 2*smFact, wtmp2////Duplicate/O wtmp2, root:dif2smooth3//	Duplicate/O wtmp2,wtmp3				// we mung one copy and need an unmunged version also//	//	findPeaksIn2ndDeriv(wtmp2)////PutLinesOnGraph(results, "Graph7", DimSize(results, 0))//	Wave Results////print GetWavesDataFolder(results, 2)//	maxPeaks = min(maxPeaks, DimSize(results, 0))//	Variable nRows = DimSize(results, 0)//	//	Variable avgWidth=0					// for width not too far from average width criteria//	//	Variable i=0,peakNum=0,numBadPeaks=0//	for (i = 0; i < nRows; i += 1)//		Variable x0= Results[i][0]//		Variable xr= Results[i][4]//		Variable xl= Results[i][2]////		Variable widthEst//		Variable rightWidthEst, leftWidthEst, leftWidthFraction	// JW 071031//		do//			if( (x0-xl) < 1 )//				widthEst= xr-x0				// if up against the left edge, use right width//				break//			endif//			if( (xr-x0) < 1 )//				widthEst= x0-xl				// similar for right edge//				break//			endif//			Variable ratio= (xr-x0)/ (x0-xl)	// right width/left width//			if( (ratio < 0.5) || (ratio>2) )//				widthEst=2* min(xr-x0, x0-xl)	// take smaller of widths if one is much larger//				break//			endif//			widthEst= xr-xl//		while(0)////		rightWidthEst = xr-x0						// JW 071031//		leftWidthEst = x0-xl						// JW 071031//		leftWidthFraction = leftWidthEst/widthEst	// JW 071031//		//		if( !(widthEst>3) )						// this probably will neverhappen but if it did, we are probably out of real peaks//			break//		endif////		Variable impulseWidth= 2*(2*smFact+1)//		if( widthEst > 1.3*impulseWidth )//			widthEst= sqrt(widthEst^2 - impulseWidth^2)//		else//			widthEst= widthEst/2//		endif//		widthEst /= sqrt(6)//		leftWidthEst = widthEst*leftWidthFraction//		rightWidthEst = widthEst - leftWidthEst//		//		Variable yl= wtmp1[xl], y0= wtmp1[x0], yr= wtmp1[xr]//		Variable bl0 = min(yr, yl)//		//		Variable heightEst= 1.3*(y0-bl0)//		if (heightEst < 0)//			continue//		endif//		//		Variable avgNoiseEst= noiseEst/(1.35*sqrt(2*smFact+1))//		Variable minH= avgNoiseEst*8//		Variable saveMinH = minH//		//		// throw in an additional penalty if width is far away from the average//		if( avgWidth>0 )//			minH *= sqrt( (widthEst/avgWidth)^2 + (avgWidth/widthEst)^2 )//		endif////print "i=",i,"; point=", x0, "; original minH=",saveMinH,"; minH=",minH,"; heightEst=",heightEst, "; widthEst=", widthEst//		if( heightEst >  minH )//			Redimension/N=(peakNum+1,numPeakInfoColumns) W_AutoPeakInfo//			avgWidth= (avgWidth*peakNum+widthEst)/(peakNum+1)//			W_AutoPeakInfo[peakNum]={{x0+pBegin},{widthEst},{heightEst},{leftWidthEst},{rightWidthEst}}//			peakNum+=1//		else//			if( peakNum == 0 )//				break					// if very first peak is bad, then give up//			endif//			numBadPeaks += 1//			if( numBadPeaks > 3 )//				break//			endif//		endif//		if(peakNum>=maxPeaks)//			break;//		endif//	endfor//	KillDataFolder :////	return 	peakNumreturn 0endFunction AdjustAutoPeakInfoForX(wpi,yData,xData)	Wave wpi,yData	WAVE/Z xData		Variable imax= DimSize(wpi,0),i=0	do		if( WaveExists(xData) )			Variable p0= wpi[i][0]			Variable pw= wpi[i][1]/2			wpi[i][0]=xData[p0]			wpi[i][1]= abs(xData[p0+pw] - xData[p0-pw])			Variable pLw = wpi[i][3]			wpi[i][3]= abs(xData[p0] - xData[p0-pLw])			Variable pRw = wpi[i][4]			wpi[i][4]= abs(xData[p0-pRw] - xData[p0])		else			wpi[i][0]=pnt2x(yData,wpi[i][0])			wpi[i][1]=  abs(wpi[i][1]*deltax(yData))			wpi[i][3]=  abs(wpi[i][3]*deltax(yData))			wpi[i][4]=  abs(wpi[i][4]*deltax(yData))		endif		i+=1	while(i<imax)endFunction TrimAmpAutoPeakInfo(wpi,gMinPeakFraction)	Wave wpi	Variable gMinPeakFraction		Variable i= DimSize(wpi,0)-1					// index of last row	Variable ymin= wpi[0][2]*gMinPeakFraction	// user want peaks to be bigger than this		do		if( wpi[i][2] < ymin )			DeletePoints i,i,wpi		endif		i -= 1	while(i>0)	return DimSize(wpi,0)endFunction carpet_display(ctrlName)	String ctrlName		DFREF DF = GetDataFolderDFR()		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	String DFS_common="root:internalUse:"+panelName+":panel_common"	DFREF DF_common=$DFS_common	DFREF DFR_panel=$DF_panel	SetActiveSubwindow $winname(0,65)		SVAR sourcePathlist=DF_common:gs_sourcePathlist	SVAR sourcenamelist=DF_common:gs_sourcenamelist	SVAR toppath=DF_common:gs_TopItemPath	SVAR topName = DF_common:gs_TopItemName	NVAR toplayernum=DF_common:gv_toplayernum	NVAR topwaverow=DF_common:gv_topwaverow	NVAR topdfrow=DF_common:gv_topdfrow	WAVE/t w_DF=DF_common:w_DF	WAVE/t w_sourceNames=DF_common:w_sourceNames	Wave/b w_sourceNamesSel=DF_common:w_sourceNamesSel	NVAR autolayerflag=DF_common:gv_autolayerflag		controlinfo DCs_ck40	variable appflag=V_value		controlinfo DCs_ck41	variable liveflag=V_value		Variable displayflag=1		if (liveflag)		displayflag=5//live single image	else		if (appflag)			displayflag=3		else						Variable multselflag=0			Variable index=0			do				if  ((w_sourceNamesSel[index] == 8)||(w_sourceNamesSel[index]==9))					multselflag=1					break				endif				index+=1			while (index<numpnts(w_sourceNamesSel))					if (multselflag)				prompt displayflag,"Select display mode",popup,"All;Seperate;"				doprompt "Select display mode",displayflag					if (V_Flag)					return 0				endif			endif		endif	endif		image_display(displayflag)endFunction image_display(d_flag)	Variable d_flag		DFREF DF = GetDataFolderDFR()		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	String DFS_common="root:internalUse:"+panelName+":panel_common"	DFREF DF_common=$DFS_common	DFREF DFR_panel=$DF_panel	SetActiveSubwindow $winname(0,65)		SVAR sourcePathlist=DF_common:gs_sourcePathlist	SVAR sourcenamelist=DF_common:gs_sourcenamelist	SVAR toppath=DF_common:gs_TopItemPath	SVAR topName = DF_common:gs_TopItemName	NVAR toplayernum=DF_common:gv_toplayernum	NVAR topwaverow=DF_common:gv_topwaverow	NVAR topdfrow=DF_common:gv_topdfrow	WAVE/t w_DF=DF_common:w_DF	WAVE/t w_sourceNames=DF_common:w_sourceNames	Wave/b w_sourceNamesSel=DF_common:w_sourceNamesSel	NVAR autolayerflag=DF_common:gv_autolayerflag			Variable index,datalayernum	String wave_path,wave_name	Variable tempsel		if (d_flag==3)		String gN=WinName(1,1)	   	doWindow/F $gN	endif		Variable imageindex=0		do			if ((w_sourceNamesSel[index] == 1)||(w_sourceNamesSel[index] == 8)||(w_sourceNamesSel[index]==9))			toppath=w_DF[topdfrow]+w_sourceNames[index]			topname=w_sourceNames[index]			tempsel=w_sourceNamesSel[index]			w_sourceNamesSel[index]=0				if (strlen(toppath)==0)				break			endif			wave_path=toppath				Wave data=$wave_path				//Panelimageupdate(3)					if (wavedims(data)>2)					GetProList(DF_common,data,nan)				datalayernum=toplayernum			else				datalayernum=0			endif				if (d_flag==3)				gN=WinName(0,1)	   			 doWindow/F $gN			else				if ((d_flag==2)||(imageindex==0))					Display  /K=1/W= (0, 0,400, 200)					gN=WinName(0,1)	   				doWindow/F $gN	   				gN=uniquename("IMG_",6,0)	   			 	Dowindow /C $gN	   				SetWindow $gN, hook(MyHook) = MygraphHook	   			elseif (d_flag==1)	   		 		gN=WinName(0,1)	   				doWindow/F $gN				endif			endif			Attachtobottom(winname(1,65),gN,3)							if (d_flag!=5)				newDatafolder /o/s $("root:graphsave:images:"+gN)	 				String wname=nameofwave(data)	   				GetLayerimage(data,datalayernum)				duplicate /o templayerimage,$wname				killwaves/Z templayerimage					Wave image=$wname								else				Wave image=DF_common:w_image			endif						AppendImage /W=$gN image				image_Style(gN,0)				w_sourceNamesSel[index]=tempsel						imageindex+=1		endif		index+=1	while (index<numpnts(w_sourceNamesSel))	Label bottom "k\\B//\\M (\\S-1\\M)"	SetDatafolder DF	EndFunction fill_to_zero(ctrlName)	String ctrlName		String gN = WinName(1,1)	if (strlen(gN) == 0)		return -1	endif		if (stringmatch(ctrlName, "DCs_b2"))	// "no fill"		ModifyGraph/w=$gN mode=0		return 1	endif		String List = TraceNameList(gN, ";",1)	String TraceName	Variable items = ItemsInList(List,";")		Variable index = 0	//items-1	do		TraceName = StringFromList(index,List)		ModifyGraph/w=$gN mode=7,hbFill=1,useNegPat($Tracename)=1,hBarNegFill($TraceName)=1	index += 1	while (index < items)EndFunction sv_offset1(ctrlName,varNum,varStr,varName)	String ctrlName	Variable varNum	String varStr	String varName		String panelname=winname(0,65)	String DF_panel="root:internalUse:"+panelName	DFREF DFR_panel=$DF_panel		NVAR x_offset = DFR_panel:gv_x_offset	NVAR y_offset = DFR_panel:gv_y_offset		ControlInfo offs_sv3	x_offset = v_value	ControlInfo offs_sv4	y_offset = v_value		//ControlUpdate DCs_sl0	//ControlUpdate DCs_sl1	Slider offs_sl1, value=y_offset	Slider offs_sl0, value=x_offset	slider_offset("dum", NaN, 1)EndFunction DC_Style_proc(ctrlname, value)String ctrlnameVariable value	String gn=winname(1,1)//	controlinfo DCs_styck0	ModifyGraph/Z /W=$gn zero(bottom)=1	controlinfo DCs_styck2		if (v_value)	controlinfo DCs_C0	   DC_Style(gn,v_value)	endifend			Function/s append_axis_label(graphname,axisN,dim)	String graphname, axisN	Variable dim		if (dim==1)		String Trlist=TraceNameList(graphname,";",1)		String TraceName=StringFromlist(0,Trlist)		Wave Trace=TraceNameToWaveRef(graphname,Tracename)		String notestr=note(Trace)	endif		String x_label, y_label, z_label		String MatrixType = StringByKey("MatrixType",notestr,"=","\r")	String XScanType = StringByKey("XScanType",notestr,"=","\r")	String AngleMapping = StringByKey("AngleMapping",notestr,"=","\r")	String EnergyScale = StringByKey("EnergyScale",notestr,"=","\r")		// x-axis	if (stringmatch(notestr,"*AngleMapping*") == 0)		x_label = ""	else		if (stringmatch(AngleMapping, "*none*"))			x_label = "Emission Angle (deg)"		else			x_label = "Parallel Momentum (\S-1\M)"		endif	endif		// y-axis	if (stringmatch(notestr,"*EnergyScale*") == 0)		y_label = ""	else		if (stringmatch(EnergyScale,"*kinetic*"))			y_label = "Kinetic Energy (eV)"		else			y_label = "E-E\\BF\\M (eV)"		endif	endif		// z-axis	if (stringmatch(notestr,"*XScanType*") == 0)		z_label = ""	else		if (stringmatch(XScanType,"Scienta*"))			//z_label = "Intensity (kcts/s/channel)"			z_label = "Intensity (cts/s/pixel)"		else			z_label = "Intensity (kcts/s)"		endif	endif		// suppress dimension labels?//	if (suppress_flag)//		suppress_string= "\\u#2"//	else//		suppress_string = ""//	endif			End//////////////////////////////////////////////////////////////////////////////////////////////////// check-box switchesFunction c_kxkykzplot(Ctrlname,value)String ctrlnameVariable valueif (value==1)strswitch (ctrlname)		case "DCs_ck0":		checkbox DCs_ck1 value=0		break  		case "DCs_ck1":		checkbox DCs_ck0 value=0		break  EndswitchendifEndFunction image_color(ctrlName,popNum,popStr)	String ctrlName	Variable popNum	String popStr	ModifyImage w_image ctab= {*,*,$popStr,0}EndFunction image_contrast(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	WAVE M = root:internalUse:panel_common:w_image	NVAR c_min = root:internalUse:disp:gv_d_low	NVAR c_max = root:internalUse:disp:gv_d_high	Imagestats/M=1 M		ControlInfo car_p0; String table = s_value		Variable from = v_min + c_min * (v_max - v_min)	Variable to = v_min + c_max * (v_max - v_min)	ModifyImage w_image ctab= {from, to, $table,0}End// a first attempt to create meaningful x,y,z labels for carpets and maps// dim=x,y,z//											Function/s i_photo_axis_label(notestr,dim,)	String notestr, dim		String x_label, y_label, z_label		String MatrixType = StringByKey("MatrixType",notestr,"=","\r")	String XScanType = StringByKey("XScanType",notestr,"=","\r")	String AngleMapping = StringByKey("AngleMapping",notestr,"=","\r")	String EnergyScale = StringByKey("EnergyScale",notestr,"=","\r")		// x-axis	if (stringmatch(notestr,"*AngleMapping*") == 0)		x_label = ""	else		if (stringmatch(AngleMapping, "*none*"))			x_label = "Emission Angle (deg)"		else			x_label = "Parallel Momentum (\S-1\M)"		endif	endif		// y-axis	if (stringmatch(notestr,"*EnergyScale*") == 0)		y_label = ""	else		if (stringmatch(EnergyScale,"*kinetic*"))			y_label = "Kinetic Energy (eV)"		else			y_label = "E-E\\BF\\M (eV)"		endif	endif		// z-axis	if (stringmatch(notestr,"*XScanType*") == 0)		z_label = ""	else		if (stringmatch(XScanType,"Scienta*"))			//z_label = "Intensity (kcts/s/channel)"			z_label = "Intensity (cts/s/pixel)"		else			z_label = "Intensity (kcts/s)"		endif	endif		// suppress dimension labels?//	if (suppress_flag)//		suppress_string= "\\u#2"//	else//		suppress_string = ""//	endif			strswitch(dim)	// string switch		case "x":						return x_label			break		case "y":						return y_label			break		case "z":						return z_label			break		endswitchEnd// add/remove textbox to/from current top-graphFunction add_textbox(w)	WAVE w		if (waveexists(w))		ControlInfo/W=DC_display_panel car_c0; Variable file_flag = v_value		ControlInfo/W=DC_display_panel car_c1; Variable angle_flag = v_value		String noteStr = note(w)		String fileName = StringByKey("FileName", noteStr, "=", "\r")		String th = num2str(round(NumberByKey("InitialThetaManipulator", noteStr, "=", "\r")*10)/10)		String ph = num2str(round(NumberByKey("InitialPhiManipulator", noteStr, "=", "\r")*10)/10)			String text = ""		TextBox/K /N=text13		if (file_flag)			text += "\\Z09"+fileName			if (angle_flag)				text += "\r"			endif		endif		if (angle_flag)			text += "\\Z09th="+th+", ph="+ph		endif		if (file_flag || angle_flag)			ControlInfo/W=DC_display_panel car_p1			TextBox/C/N=text13/A=LB text			TextBox/C/N=text13/F=0/B=1/G=(v_red, v_green, v_blue)			TextBox/C/N=text13/X=3.00/Y=3.00			if (stringmatch(WinName(0,1),"DC_display_panel"))				TextBox/C/N=text13/X=3.00/Y=45.00			endif		endif	else		return 0	endifEndFunction c_annotation(ctrlName,checked)	String ctrlName	Variable checked		SVAR topPath = root:internalUse:panel_common:gs_topItemPath	add_textbox($topPath)EndFunction annotation_color(ctrlName,popNum,popStr)	String ctrlName	Variable popNum	String popStr		SVAR topPath = root:internalUse:panel_common:gs_topItemPath	add_textbox($topPath)EndFunction SubWindowDraw()	String Wname=winname(0,1)	String Wlist,Wavesname,noteStr,SampleName,TextStr	if (Strlen(ImagenameList(wname,";"))>0)		Wlist=Imagenamelist(Wname,";")		Wavesname=StringFromList(0,Wlist)		Wave Image=ImagenametoWaveref(Wname,Wavesname)		else		Wlist=TracenameList(Wname,";",1)		Wavesname=StringFromList(0,Wlist)		Wave Image=TraceNametowaveref(Wname,Wavesname)	endif	//ReadDetailWaveNote(Image)	Wave /T WaveInfoL	String WaveinfoS=WaveInfoL[0]+"\r"+WaveInfoL[1]+"\r"+WaveInfoL[2]+"\r"+WaveInfoL[3]//+"\r\JL\B"+line4	TextBox /W=$Wname/B=3/C/N=Sampleinfo/F=0/A=LB WaveinfoS	killWaves /Z waveVars,waveinfoLEndFunction CheckManualNote(Data)Wave DataString NoteStr=note(Data)if (strSearch(NoteStr,"Manual",0)!=-1)return 1elsereturn 0endifEndFunction SubWindowKill()	String Wname=winname(0,1)	//modifyGraph /W=$Wname axisEnab(left)={0.00,1}	//String SubWname=Wname+"#"+Stringfromlist(0,ChildWindowlist(Wname),";")	//KillWindow $subWname	TextBox /K/N=SampleinfoEndFunction delGapfromTable(ctrlname)String CtrlnameString DF=GetDatafolder(1)NVAR Gapnum=root:internalUse:SymEDCFit:gapnumGapnum-=1String Wname="gapsize"+num2str(Gapnum)newDatafolder/o/s root:Gapsizedowindow /K KxKytableWave Gap=$Wnamekillwaves GapEditKxKyTable("Insert")SetDatafolder $DFEndFunction InsertGaptoTable(ctrlname)String CtrlnameString DF=GetDatafolder(1)NVAR Gapnum=root:internalUse:SymEDCFit:gapnumString Wname="gapsize"+num2str(Gapnum)newDatafolder/o/s root:Gapsizemake /o/n=1,$WnameWave Gapsize=$WnameGapnum+=1EditKxKyTable("Insert")SetDatafolder $DFEndFunction CalKxkyTable(ctrlname)String CtrlnameString df=GetDatafolder(1)setDatafolder root:gapsizewave xKxky,xtheta,xcos2theta,kx,kyVariable num=numpnts(ky)redimension /n=(num) xKxky,xtheta,xcos2thetaVariable index=0Variable TempKX,TempKy,TempA,TempThetaNVAR A=root:internalUse:SymEDCFit:CalANVAR CalAzi=root:internalUse:SymEDCFit:CalAzidoTempKx=abs(abs(Kx[index])*cos(CalAzi/180*pi)+abs(Ky[index])*sin(CalAzi/180*pi))TempKy=abs(abs(Ky[index])*cos(CalAzi/180*pi)-abs(Kx[index])*sin(CalAzi/180*pi))TempA=pi/ATemptheta=atan((TempA-TempKx)/(TempA-TempKy))xtheta[index]=(Temptheta/pi*180)xtheta=(xtheta<0)?(abs(xtheta)):(xtheta)xtheta=(xtheta>45)?(90-xtheta):(xtheta)xcos2theta[index]=cos(2*xtheta[index]/180*pi)xkxky[index]=(abs(cos(TempKx*A)-cos(TempKy*A))/2)index+=1while (index<numpnts(ky))SetDatafolder $DFEndFunction EditKxKyTable(CtrlName)String ctrlNameString DF=GetDatafolder(1)newDatafolder /o/s root:GapsizedoWindow /K KxKytableNVAR Gapnum=root:internalUse:SymEDCFit:gapnumif (waveexists(xKxky))elsemake /o/n=1 xKxKymake /o/n=1 xthetamake /o/n=1 xcos2thetamake /o/n=1 kxmake /o/n=1 kyendifwave xKxky,xtheta,xcos2theta,kx,kyedit /W=(100,100,800,300) /N=KxKyTable ky,kx,xtheta,xcos2theta,xkxky as "KxKyTable" Variable index=0String Wnameif (Gapnum==0)elsedo Wname="Gapsize"+num2str(index)Appendtotable /W=KxkyTable $Wnameindex+=1while (index<gapnum)endifmodifyTable width=70Setdatafolder $DFEndFunction CalCosKXKY(ctrlname)String ctrlnameNVAR Kx=root:internalUse:SymEDCFit:CalKxNVAR Ky=root:internalUse:SymEDCFit:CalKyNVAR theta=root:internalUse:SymEDCFit:CalthetaNVAR cos2theta=root:internalUse:SymEDCFit:Calcos2thetaNVAR coskxky=root:internalUse:SymEDCFit:CalcoskxkyNVAR A=root:internalUse:SymEDCFit:CalANVAR CalAzi=root:internalUse:SymEDCFit:CalAziVariable TempKX,TempKy,TempA,TempThetaTempKx=abs(abs(Kx)*cos(CalAzi/180*pi)+abs(Ky)*sin(CalAzi/180*pi))TempKy=abs(abs(Ky)*cos(CalAzi/180*pi)-abs(Kx)*sin(CalAzi/180*pi))TempA=pi/ATemptheta=atan((TempA-TempKx)/(TempA-TempKy))theta=(Temptheta/pi*180)theta=(theta>45)?(90-theta):(theta)theta=(theta<0)?(abs(theta)):(theta)cos2theta=cos(2*theta)coskxky=(abs(cos(TempKx*A)-cos(TempKy*A))/2)EndFunction ChooseFitSymWave(CtrlName,row,col,event)String ctrlName	Variable row	Variable col	Variable event	SVAR m=root:internalUse:SymEDCFit:FitWavePath	Wave/T SourceName=root:internalUse:SymEDCFit:WaveSourceList	m=SourceName[row]	Wave Data=$m	Duplicate /o Data,root:internalUse:SymEDCFit:TryWave	removefromgraph /Z fitWaveEndFunction MirrorEDCall(ctrlname)String CtrlNameSVAR PathLst=root:InternalUse:panel_common:gs_sourcePathListVariable EF=0//root:InternalUse:disp:MirrorEFVariable Windex=0String Pathdo	path=StringfromList(Windex,PathLst)	if (strlen(path)<=0)	break	endif	Wave Data = $path	MirrorEDCInt(Data,EF)Windex+=1while (1)	End/////////////////////sep_append/////////////Function Sep_Append()	String gname=winname(0,1)	String Parname=GetBrowserSelection(0)	Wave Data=$Parname		//STring gname=winname(1,1)		//Wave Data=WaveRefIndexed(winname(0,1), 0, 1)		Variable xrange=0.001,Yoffpar=0.8	prompt xrange,"Peakrange"	prompt yoffpar, "Yoffset"	Variable removeflag=1	prompt removeflag,"Display option:",popup,"Append;Remove;"		doprompt "Input for sep Append",xrange,yoffpar		Sep_append_macro(gname,Data,xrange,yoffpar,0,removeflag)EndFunction GP_SepAppend()	//String gname=winname(0,1)	//String Parname=GetBrowserSelection(0)	//Wave Data=$Parname		String gname=winname(1,1)		Wave Data=WaveRefIndexed(winname(0,1), 0, 1)		Variable xrange=0.001,Yoffpar=0.8	prompt xrange,"Peakrange"	prompt yoffpar, "Yoffset"	Variable removeflag=0	prompt removeflag,"Display option:",popup,"Append;Remove;"		doprompt "Input for sep Append",xrange,yoffpar,removeflag		Sep_append_macro(gname,Data,xrange,yoffpar,0,removeflag)EndFunction Sep_append_macro(winame,peakwave,Xrange,Yoffpar,controlflag,removeflag)	String winame	Wave peakwave	Variable Xrange,Yoffpar,controlflag	Variable removeflag		DFREF DF=GetDatafolderDFR()		String gname=winame	String List = TraceNameList(gname, ";",1)		String TraceName,PointName,PointN,ListPos=""	String ListTrace=List		Make /o/FREE/Wave /n=(numpnts(peakwave)) Posreflist		Variable items = ItemsInList(List,";")	Variable index=0		Variable multiwaveflag=0,MDCflag=0,Num0	String rawwaname=""	String Waname	String newList=""	Variable tracenum=0	do		TraceName=Stringfromlist(index,List,";")		if (strsearch(TraceName,"_Pos_",0)!=-1)			ListPos+=TraceName+","			ListTrace=RemoveFromList(TraceName,ListTrace,";")		else			if (index>0)				ListPos+=";"			endif						if ((strsearch(TraceName, "_m",0))!=-1)				Num0=strsearch(TraceName, "_m",0)				MDCflag=1			elseif ((strsearch(TraceName, "_e",0))!=-1)				Num0=strsearch(TraceName, "_e",0)				MDCflag=2			else				MDCflag=0				multiwaveflag=2			endif						if (multiwaveflag==0)				rawwaname=TraceName[num0-4,num0-1]				multiwaveflag=1			elseif (multiwaveflag==1)				waname=TraceName[num0-4,num0-1]				if (stringmatch(waname,rawwaname))					multiwaveflag=1				else					multiwaveflag=2				endif			endif			tracenum+=1		endif		index+=1	while (index<items)		ListPos+=";"		String O_Pos_list	//List=listN1	items=ItemsInList(Listtrace,";")	if (tracenum!=numpnts(peakwave))		SetDatafolder DF		return 0	endif	//print listpos	//print listtrace		index=0		do		TraceName=Stringfromlist(index,ListTrace,";")			newList+=TraceName+","				if (mdcflag==1)			Num0=strsearch(TraceName, "_m",0)			Waname=TraceName[0,num0+6]		elseif (mdcflag==2)			Num0=strsearch(TraceName, "_e",0)			Waname=TraceName[0,num0+6]		else 			Num0=0			Waname=TraceName		endif				if (multiwaveflag==2)			pointN=Waname+"_Pos_"+nameofwave(peakwave)[0,4]		else			pointN=Waname+"_Pos_"+nameofwave(peakwave)[0,4]//TraceName[Num0+3,inf]+		endif				Wave trace=TraceNameToWaveRef(gname,TraceName)				DFREF SAVEDF=	$Getwavesdatafolder(trace,1)				SetDatafolder SaveDF				newDatafolder /o/s Sep_disp				if (removeflag==2)			removefromgraph /Z /W=$gname  $pointN			Killwaves /Z $pointN		else					Make /o/n=1 $pointN			Wave point=$pointN			Setscale /P x,peakwave[index],peakwave[index],Point					Point=wavemax(trace,(peakwave[index]-Xrange),(peakwave[index]+Xrange))*Yoffpar					String tracei=Traceinfo(gname,TraceName,0)			Variable  p2=strsearch(tracei,"offset(x)",0)+11			Variable p3=strsearch(tracei,",",p2)+1			Variable p4=strsearch(tracei,"}",p2)-1			Variable xoffset=str2num(tracei[p2,p3-2])			Variable yoffset=str2num(tracei[p3,p4])					checkdisplayed /W=$gname $pointN					O_Pos_list=Stringfromlist(index,ListPos,";")			//O_Pos_list=RemoveFromList(pointN,O_Pos_list,",")					if (V_flag==0)				//removefromgraph /Z/W=$gname $pointN				AppendToGraph /W=$gname $pointN				newList+=pointN+","+O_Pos_list				ModifyGraph /W=$gname mode($pointN)=3,marker($pointN)=6			else				newList+=O_Pos_list			endif			ModifyGraph /W=$gname offset($pointN)={xoffset,yoffset}		endif				index+=1	while (index<items)		SetDatafolder DFEnd