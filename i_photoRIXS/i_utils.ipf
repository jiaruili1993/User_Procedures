#pragma rtGlobals=1		// Use modern global access method.#pragma version = 2.00#pragma ModuleName=i_utils#pragma IgorVersion = 5.0// Note that this only scans the first screen it will find.//// Returns a string with integers: "left;top;right;bottom"Function/S utils_screenDimensions()	String screen1 = StringByKey("SCREEN1", IgorInfo(0))	String dims = screen1[strsearch(screen1, "RECT=", 2)+5,strlen(screen1)]	return ReplaceString(",", dims, ";")End// returns the window size in pixels, absolute, in V_top, V_left, V_right, V_bottomFunction utils_windowSize(windowName)	String windowName	// The reason why this is such a mess is that:	// 1. GetWindow only supplies absolute coordinates with gsize. But that is in points.	// 2. GetWindow supplies relative coords with gsizeDC. That is in pixels.	// 3. ALL Control positions and -sizes are in pixels.	// 4. Igor of course does not supply a function that converts pixels <-> points.	Execute "GetWindow '"+windowName+"' wsizeDC"	NVAR V_bottom, V_top, V_right, V_left	Variable pixelHeight = V_bottom-V_top	Variable pixelWidth = V_right-V_left	Execute "GetWindow '"+windowName+"' wsize"	NVAR V_bottom, V_top, V_right, V_left	Variable pointHeight = V_bottom-V_top	Variable pointWidth = V_right-V_left	Variable point2pixWidth = pixelWidth / pointWidth	Variable point2pixHeight = pixelHeight / pointHeight	V_bottom *= point2pixHeight	V_top *= point2pixHeight	V_left *= point2pixWidth	V_right *= point2pixWidth	V_bottom = round(V_bottom)	V_top = round(V_top)	V_left = round(V_left)	V_right = round(V_right)End// Resizes the window to the given size (in pixels).Function utils_resizeWindow(windowName, width, height)	String windowName	Variable width, height	utils_windowSize(windowName)	NVAR V_bottom, V_top, V_right, V_left	utils_moveWindow(windowName, V_left, V_top, V_left+width, V_top+height)End// This is the same as the MoveWindow function suppleid by Igor.// Only difference: this here has units pixels, so this one here is actually useful.Function utils_moveWindow(windowName, left, top, right, bottom)	String windowName	Variable left, top, right, bottom	// This is priceless. I mean, how stupid do you have to be in order to screw this up:	// - GetWindow wsize returns in unit points.	// - GetWindow wsizeDC returns in unit pixels.	// - the default unit of ALL controls and ALL draw* commands is pixels.	// - MoveWindow offers units points(default), cm, inches.	// WTF?! Did anyone at Igor even THINK before they created this? 	// How am I going to move/resize a window in POINTS when all I know/care about is the	// size of the controls (which comes in PIXELS)? Especially when Igor does not provide	// a function to CONVERT THE FRIGGIN UNITS?!	//	// The reason why this is such a mess is that:	// 1. GetWindow only supplies absolute coordinates with gsize. But that is in points.	// 2. GetWindow supplies relative coords with gsizeDC. That is in pixels.	// 3. ALL Control positions and -sizes are in pixels.	// 4. Igor of course does not supply a function that converts pixels <-> points.	Execute "GetWindow '"+windowName+"' wsizeDC"	NVAR V_bottom, V_top, V_right, V_left	Variable pixelHeight = V_bottom-V_top	Variable pixelWidth = V_right-V_left	Execute "GetWindow '"+windowName+"' wsize"	NVAR V_bottom, V_top, V_right, V_left	Variable pointHeight = V_bottom-V_top	Variable pointWidth = V_right-V_left	Variable pix2pointWidth = pointWidth / pixelWidth	Variable pix2pointHeight = pointHeight / pixelHeight	String cmd	sprintf cmd, "MoveWindow/W='%s' %d, %d, %d, %d\r", windowName, left*pix2pointWidth, top*pix2pointHeight, right*pix2pointWidth, bottom*pix2pointHeight	Execute cmdEnd// moves a window to the position (in pixels) posx, posy. If no position is// specified, tries to find a free area on the screen to put the window there.// This function is rather slow, so use it sparsely.// the argument win is the types of windows to be included in the auto placement.// See the WinList() help for details.Function utils_autoPosWindow(windowName, [posx, posy,win])	String windowName	Variable win	Variable posx, posy		String DF = GetDataFolder(1)	SetDataFolder root:internalUse	utils_windowSize(windowName)	NVAR V_bottom, V_top, V_right, V_left	Variable myTop = V_top	Variable myLeft = V_left	Variable myBottom = V_bottom	Variable myRight = V_right	Variable myWidth = myRight - myLeft	Variable myHeight = myBottom - myTop	if (ParamIsDefault(posx) == 1 || ParamIsDefault(posy) == 1)		String dims = utils_screenDimensions()		Variable ScrLeft = str2num(StringFromList(0, dims))		Variable ScrTop = str2num(StringFromList(1, dims))		Variable ScrRight = str2num(StringFromList(2, dims))		Variable ScrBottom = str2num(StringFromList(3, dims))		Variable ScrWidth = ScrRight - ScrLeft		Variable ScrHeight = ScrBottom - ScrTop		// Igor does not include the managed (i.e. the OS-specific border around the window		// which usually includes the minimize, maximize, and close buttons, etc) part of		// the window when reporting its size. These are just some guesses as to make it 		// look prettier, but they are probably OS-specific. There is no way I know of to		// fix this problem. -- Felix S.		Variable OSmarginLR = 8 // left/right overlap margin		Variable OSmarginTB = 32 // top/bottom overlap margin		String wlist = WinList("*", ";", "")		if (! ParamIsDefault(win))			wlist = WinList("*", ";", "WIN:"+num2str(win))		endif		Variable i		Variable minHeight = inf		Variable foundOverlap		myLeft = 0		myTop = 0		myRight = myWidth		myBottom = myHeight		// This is how it works:		// 1. 	start from the top left corner.		// 2. 	is there any window from the window list which overlaps? If yes, move to the right s.t.		//		my left border is on the right border of the overlapping window. If no, autoplacement		//		is successful. Place window and exit.		// 3. 	repeat 2.) until either there is no overlapping window found or we are at the very right end of		//		the screen.		// 3a.	At the very right end of screen? -> move down by the highest lower border of all the		//		windows that were found to be overlapping. Start at 2. again. If we can't move down		//		anymore, there was no space left and autoplacement is unsuccessful.		do			foundOverlap = 0			minHeight = inf			for (i = 0; i < ItemsInList(wlist); i += 1)				if (stringmatch(StringFromList(i,wlist),windowName))					continue				endif				utils_windowSize(StringFromList(i, wlist))				NVAR V_bottom, V_top, V_right, V_left				if (myLeft > V_right+OSmarginLR || myRight < V_left-OSmarginLR || myTop > V_bottom+OSmarginTB || myBottom < V_top-OSmarginTB)					continue // this window does not overlap with me. Continue.				endif				minHeight = min(V_bottom, minHeight)				// Find out which way to move the window in order to clear the other window.				if (V_right + myWidth + OSmarginLR < ScrRight) // we can still move to the right. Do it.					myRight = V_right + myWidth + 1 + OSmarginLR					myLeft = V_right + 1 + OSmarginLR					foundOverlap = 1					break				elseif (myBottom + minHeight + OSmarginTB < ScrBottom) // we were all the way to the right. -> next line.					myBottom += minHeight + 1 + OSmarginTB					myTop += minHeight + 1 + OSmarginTB					myLeft = 0					myRight = myWidth					foundOverlap = 1					break				else // arrived at right bottom of screen without being able to find a free spot.					SetDataFolder $DF					return 0				endif			endfor		while (foundOverlap)		utils_moveWindow(windowName, myLeft, myTop, myRight, myBottom)	else		utils_moveWindow(windowName, posx, posy, posx+myWidth, posy+myHeight)	endif	SetDataFolder $DF	return 1EndFunction utils_progressDlg([message, done, numDone, numNotDone, numTotal, title, whenDone, posx, posy, level])	String message	Variable done //	Variable numDone //	Variable numNotDone //	Variable numTotal //	String title //	Variable posx, posy //	Variable level	String whenDone //	String DF = GetDataFolder(1)	SetDataFolder root:internalUse		if (! WaveExists(progressDlg_msg))		Make/T/N=3 progressDlg_msg		progressDlg_msg[] = ""	endif	if (! WaveExists(progressDlg_percent))		Make/N=(3,2) progressDlg_percent		progressDlg_percent[][] = NaN	endif		if (ParamIsDefault(title) == 1)		title = "Progress"	endif	if (ParamIsDefault(message) == 1)		message = "Progress"	endif	if (ParamIsDefault(whenDone) == 1)		whenDone = "close"	endif	String topWindow = WinName(0,1)	if (strlen(WinList("ProgressDlg", ";", "WIN:64")) == 0)		NewPanel/K=1/W=(0,0,310,50*level+75)/N=ProgressDlg as title//		ModifyPanel/W=ProgressDlg fixedSize=1		if (ParamIsDefault(posx) == 1 || ParamIsDefault(posy) == 1)			if (strlen(topWindow)!=0)				utils_autoPosWindow("ProgressDlg",win=65)			endif		else			utils_moveWindow("ProgressDlg", posx, posy, posx+310, posy+(50*level+75))		endif	endif	utils_windowSize("ProgressDlg")	NVAR V_left,V_top,V_right,V_bottom	if (V_bottom-V_top != level*50+75)		utils_moveWindow("ProgressDlg", V_left, V_top, V_right, V_top+(50*level+75))	endif		PauseUpdate		progressDlg_msg[level] = message	progressDlg_percent[level][] = NaN	if ( ParamIsDefault(numDone) == 0 && (ParamIsDefault(numTotal) == 0 || ParamIsDefault(numNotDone) == 0) )		progressDlg_percent[level][0] = numDone		progressDlg_percent[level][1] = numTotal		if (ParamIsDefault(numNotDone) == 0)			progressDlg_percent[level][1] = numDone + numNotDone		endif	endif	SetDrawLayer/W=ProgressDlg/K ProgBack	Variable i	for (i = 0; i <= level; i += 1)		DrawText/W=ProgressDlg 5, 20+i*50, progressDlg_msg[i]		if (numtype(progressDlg_percent[i][1]) == 0)			Variable perc = progressDlg_percent[i][0] / progressDlg_percent[i][1]			SetDrawEnv/W=ProgressDlg fillfgc=(32768,32768,32768)			DrawRect/W=ProgressDlg 5,25+i*50,305,45+i*50			SetDrawEnv/W=ProgressDlg fillfgc=(0,0,65535)			DrawRect/W=ProgressDlg 5,25+i*50,(5+300*perc),45+i*50			String percent			sprintf percent, "%3.1f%%", (perc*100)			SetDrawEnv/W=ProgressDlg textrgb=(65535,65535,65535)			DrawText/W=ProgressDlg 135, 43+i*50, percent		endif	endfor		SetDrawEnv/W=ProgressDlg fstyle=1	DrawText/W=ProgressDlg 5, 65+level*50, "Press & hold [Esc] to abort"		if (done == 1)		strswitch(whenDone)			case "timed":				Sleep/C=1/B/S 5			case "close":				DoWindow/K ProgressDlg				break			case "keep":				Button b_close pos={100,25+level*50}, size={100,20}, title="Close", proc=i_utils#progressDlg_ButtonClose, win=ProgressDlg				break			default:				Abort ("In utils_progressDlg: Argument whenDone="+whenDone+" is not a valid option.")		endswitch	endif		DoUpdate		if (strlen(topWindow) != 0)		Execute "DoWindow/F "+topWindow	endif	SetDataFolder $DF	return GetKeyState(0) & 32endFunction utils_Abort(msg)	String msg	DoWindow/K ProgressDlg	if (strlen(msg) > 0)		Abort msg	else		Abort	endifendStatic Function progressDlg_ButtonClose(ctrlname) : ButtonControl	String ctrlname	String topWindow = WinName(0,1)	DoWindow/K ProgressDlg	if (strlen(topWindow) != 0)		Execute "SetActiveSubwindow "+topWindow	endifend// checks the proposed name for w, return a valid name and updates the wave note if requiredFunction/s utils_uniqueName(w,folder,name, overwrite)	WAVE w; String folder, name; Variable overwrite		String Df = getdatafolder (1)	String newName, notestr		Setdatafolder $folder	if (checkName(name,1) == 0 || overwrite)	// overwrite option added 09-23-03		Setdatafolder $DF		return folder+name	else		DoAlert 2, "The default name '"+name+"' is already taken. Do you want to overwrite?\r('No' for a new name, 'cancel' to abort)"		if (v_flag == 1)			Setdatafolder $DF			return folder+name		elseif(v_flag == 2)			newName = UniqueName(name,1,0)			notestr = note(w)			Note/K w			notestr = ReplaceStringByKey("WaveName",notestr,newName,"=","\r")			Note w, notestr			Setdatafolder $DF			return folder+newName		elseif (v_flag == 3)			Setdatafolder $DF			return "-1"		endif	endifEnd// Trims leading and trailing white spaces (i.e. \t, \r, \n, and " ") off the string and returns the// resultFunction/S utils_trimSpaces(str)	String str	Variable l = 0	Variable r = strlen(str) - 1	Variable ch = char2num(str[l,l])	// Short note for people unfamiliar with ASCII: " " is 32, "\t" is 9, "\r" is 13, "\n" is 10	for(; ( ch == 32 || ch == 9 || ch == 13 || ch == 10 ) && l <= r; l+=1)		ch = char2num(str[l+1,l+1])	endfor	ch = char2num(str[r,r])	for(; ( ch == 32 || ch == 9 || ch == 13 || ch == 10 ) && r > 0; r-=1)		ch = char2num(str[r-1,r-1])	endfor	return str[l,r]EndFunction utils_text2FPwave(wt)	WAVE/t wt		Make/o/n=(numpnts(wt)) FP_wave	String str		Variable index = 0	do		str = wt[index]		FP_wave[index] = str2num(str)		index += 1	while (index < numpnts(wt))End// return the center channels of the first or last slice of a Scienta carpetFunction utils_getScientaChannel(w,flag)	WAVE w;Variable flag	String notestr = note(w)		Variable firstYchannel = NumberByKey("CCDFirstYChannel",notestr,"=","\r")	Variable lastYchannel = NumberByKey("CCDLastYChannel",notestr,"=","\r")	Variable NumberOfSlices = NumberByKey("NumberOfSlices", notestr,"=","\r")	Variable channel_slice = (lastYchannel-firstYchannel+1)/NumberOfSlices	Variable ch0 = firstYchannel + channel_slice/2 -0.5	// 04-22-04 corrected by 0.5	Variable ch1 = lastYchannel - channel_slice/2 + 0.5		if (flag == 1)		return ch1	else		return ch0	endifEnd// checks if the wave wname has attribute keyname in its note string.// Returns the value associated with keyname.// If is_required is 1 and keyname is missing(undefined), it will abort, telling the // user that a required keyname is missing in the wave.// If is_required is 0 and keyname is missing(undefined), it will return NaN//// keyname - the keyword name of the property to return --- see also the function// fileloader_NoteKeyList() in the fileloader module.// wname - the name of the wave// is_required - if 1, the function will abort with an error dialogue if the property is // not found. If 0, NaN will be returned.Function utils_getScientaValue(keyname,wname,is_required)	String keyname	String wname	Variable is_required	String notestr = note($wname)	Variable ret = NumberByKey(keyname, notestr, "=", "\r")	if (is_required != 0 && numtype(ret) != 0) 		utils_Abort("The key \""+keyname+"\" in wave "+wname+" is not defined. Please use the filetable to define it and try again.")	endif	return retEnd// Supported energy scales of the carpets are either InitialState (corresponding to the // kinetic energy of the electrons) or kinetic (where the energy scale of the carpet is // that of the kinetic electrons minus the Fermi energy). This function is returning the// kinetic energy of the electrons (in order to calculate, for example, the vacuum k vector)//// wname - the name of the wave// is_required - if 1, the function will abort with an error dialogue if the property is // not found. If 0, NaN will be returned.Function utils_getScientaEnergy(wname, is_required)	String wname	Variable is_required		Variable energy = NaN		String notestr = note($wname)	String eScale = StringByKey("EnergyScale", notestr, "=", "\r")	Variable EF = utils_getScientaValue("FermiLevel",wname, is_required)	Variable hn = utils_getScientaValue("PhotonEnergy",wname, is_required)	Variable workfunc = utils_getScientaValue("WorkFunction",wname, is_required)	if (Stringmatch(eScale,"kinetic"))		energy = hn-EF - workfunc	elseif (stringmatch(eScale,"Initial*"))		energy = hn - workfunc	else		utils_Abort("The 'EnergyScale' keyword-value must be 'kinetic' or 'InitialState'. Please change in filetable.")	endif	return energyEnd// returns a KeyList with the five angles(e.g. "omega:1;gamma:2;theta:34;alpha:2;phi:-12;"), ready// with global angle offsets and error checking to see if everything is defined in the wave.//// wname - the name of the wave// is_required - if 1, the function will abort with an error dialogue if the property is // not found. If 0, NaN will be returned.Function/S utils_getScientaAngles(wname, is_required)	String wname	Variable is_required	String notestr = note($wname)	NVAR gv_theta_offset	NVAR gv_phi_offset	NVAR gv_omega_offset	Variable gamma = utils_getScientaValue("ScientaOrientation",wname, is_required)	Variable th = utils_getScientaValue("InitialThetaManipulator",wname, is_required)	th  += utils_getScientaValue("OffsetThetaManipulator",wname, is_required)	th += gv_theta_offset	Variable al = utils_getScientaValue("InitialAlphaAnalyzer",wname, is_required)	Variable ph = utils_getScientaValue("InitialPhiManipulator",wname, is_required)	ph += utils_getScientaValue("OffsetPhiManipulator",wname, is_required)	ph += gv_phi_offset	Variable om = utils_getScientaValue("InitialOmegaManipulator",wname, is_required)	om += utils_getScientaValue("OffsetOmegaManipulator",wname, is_required)	om += gv_omega_offset	Variable signs = utils_getScientaValue("AngleSignConventions",wname, is_required)	String ret = ""	sprintf ret, "omega:%e;gamma:%e;theta:%e;alpha:%e;phi:%e;signs:%d", om, gamma, th, al, ph, signs	return retEndStatic Function is_liberal(name)	String name		return stringmatch(PossiblyQuoteName(name), name) == 0	//if (check)	//	print "lib"	//endifEnd// return a list of all DF's in an experiment that match to 'match'. Use e.g. // "!*internal*" to exclude internal stuff, or set match to "*" for a complete list// Return only DF's which contain waves of dimension dim.//	in_DF = highest datafolder, e.g. "root:"//	match = matchstring. If omitted, defaults to "*"//	dim = dimension of waves. If omitted, searches waves with all dimensions.Function/S utils_getFolderList(in_DF, [match, dim])	String in_DF, match	Variable dim		String Df = getDataFolder (1)	if (!stringmatch(in_DF[strlen(in_DF)-1],":" ) )		in_DF += ":"	endif	SetDataFolder $in_DF		String folderList = ""				Variable i = 0	for (i = 0; strlen(GetIndexedObjName(in_DF, 4, i)) != 0; i+=1)		String folderName = GetIndexedObjName(in_DF, 4, i)		if (is_liberal(folderName))			Abort "Sorry, you cannot use liberal DF-names with 'i_photo.'\rPlease rename the folder '"+folderName+"'!"		endif		String ret = utils_getFolderList(in_DF+foldername+":", match=match, dim=dim)		folderList += ret	endfor	String dimStr = "DIMS:"+num2str(dim)	if (dim == 0)		dimStr = ""	endif	if (stringmatch(in_DF, match) && strlen(WaveList("*",";",dimStr)) != 0)		folderList += in_DF+";"	endif	SetDataFolder $DF	return folderListEnd// Show or hide any kind of control in the top window. From Kevin R. BoyceFunction utils_setControlEnabled( name, disable )	String name	Variable disable		// What kind of control is it?	ControlInfo $name	Variable type = v_flag	switch( abs(type) )		case 1:		// button			Button $name disable=disable			break		case 2:		// checkbox			CheckBox $name disable=disable			break		case 3:		// popup menu			PopupMenu $name disable=disable			break		case 4:			ValDisplay $name disable=disable			break		case 5:			SetVariable $name disable=disable			break		case 6:			Chart $name disable=disable			break		case 7:			Slider $name disable=disable			break		case 8:			TabControl $name disable=disable			break		case 9:			GroupBox $name disable=disable			break		case 10:			TitleBox $name disable=disable			break		case 11:			ListBox $name disable=disable			break	endswitchEnd// rotate x,y waves in the plane. Overwrites	Static Function rotate_2D(wx,wy,angle)	WAVE wx,wy; Variable angle		duplicate/o wx t_wx	duplicate/o wy t_wy	t_wx = cos(angle*pi/180)*wx - sin(angle*pi/180)*wy	t_wy = sin(angle*pi/180)*wx + cos(angle*pi/180)*wy	wx=t_wx	wy=t_wyEnd// convert a string list in a text-wave. Separator must be ";"// creates W_StringList//// Returns the number of elements convertedFunction utils_stringList2wave(List)	String list		Variable num = itemsinlist(list)	Make/n=(num)/o/t W_StringList		String item	Variable index = 0	do		item = stringfromlist(index,list)		W_StringList[index]=item	index += 1	while (index < num)	return indexEndFunction/S utils_wave2stringList(w)	WAVE/T w		String List=""	Variable i	for(i = 0; i < DimSize(w,0); i+=1)		switch(WaveDims(w))			case 1:				List += w[i]+";"				break			case 2:				List += w[i][0]+";"				break			case 3:				List += w[i][0][0]+";"				break			case 4:				List += w[i][0][0][0]+";"				break		endswitch	endfor		return ListEndFunction utils_clearTraces([graphName])	String graphName	if (ParamIsDefault(graphName))		graphName = ""	endif		String List = TraceNameList(graphName,";",1)	String item	Variable counter = 0	do		item = StringFromList(counter,List)		RemoveFromGraph/Z $item		if (strlen(item)==0)			break		endif	counter += 1	while (1)End// convolve the wave 'w' with a Gaussian of width 'fwhm'// w is extended to both sides by linear extrapolations, using the last 5 pointsFunction utils_gaussConvolve(w,fwhm)	WAVE w	Variable fwhm		Variable ext = 5*fwhm		// extrapolation range for input-data	Variable pnt = numpnts(w)	Variable first_x = pnt2x(w,0)	Variable last_x = pnt2x(w,numpnts(w)-1)	Variable delta_x = deltax(w) * (pnt-1)	Variable sf = first_x-ext* sign(delta_x)	Variable st = last_x+ext* sign(delta_x)	Variable aux0	Variable pnt_i = round(abs(50 * delta_x/fwhm))	// interpolated wave and Gaussian: 50pnts/fwhm			if (fwhm == 0)		// don't convolve			return -1		endif		Duplicate/O w, w_x; w_x=x		Make/O/N=(pnt_i) data_long, Gaussian		SetScale/I x -(st-sf)/2, (st-sf)/2,"", Gaussian		SetScale/I x sf,st,"", data_long			Duplicate/O data_long, data_long_x	data_long_x = x		data_long = interp(x,w_x,w)		Make/O/D/N=2 w_coef	CurveFit/Q line w[0,4]		data_long[0,x2pnt(data_long,first_x)] = W_coef[0]+W_coef[1]*x 	CurveFit/Q line w[pnt-5,pnt-1]		data_long[x2pnt(data_long,first_x+delta_x), pnt_i-1] = W_coef[0]+W_coef[1]*x 			Gaussian = exp(-x^2 *4*ln(2)/FWHM^2)	aux0 = sum(Gaussian, -inf, inf)	Gaussian /= aux0				Convolve/A Gaussian data_long	w = interp(x, data_long_x, data_long) 	  	KillWaves/Z Gaussian, data_long,data_long_x, w_x, w_coef, w_sigma		End// dim is the remaining dimension. Creates the wave 'w_avg' containing the mean valuesFunction utils_getWaveAvg(w,dim,[from,to])	WAVE w	Variable dim	Variable from,to		if (ParamIsDefault(from))		from = -inf	endif	if (ParamIsDefault(to))		to = inf	endif		Variable pnt2 = dimsize(w,abs(dim-1))	Variable pnt = dimsize(w,dim)		Variable sf = dimoffset(w,dim)	Variable st = dimoffset(w,dim) + (dimsize(w,dim)-1)*dimdelta(w,dim)	Variable DC_sf = dimoffset(w,abs(dim-1))	Variable DC_st = dimoffset(w,abs(dim-1)) + (dimsize(w,abs(dim-1))-1)*dimdelta(w,abs(dim-1))	Make/O/N=(pnt) w_avg	SetScale/I x sf,st,"", w_avg	Make/O/N=(pnt2) w_DC	SetScale/I x DC_sf,DC_st,"", w_DC		if (dim == 0)		// 'e-average'	Variable index = 0		do			w_DC = w[index][p]			w_avg[index] = mean(w_DC,from,to)		index += 1		while (index < pnt)	endif		if (dim == 1)		// 'k-average'	index = 0		do			w_DC = w[p][index]			w_avg[index] = mean(w_DC,from,to)		index += 1		while (index < pnt)	endif		KillWaves/Z w_DCEndFunction utils_nFoldSymmetry(kx,ky,int,nF)	WAVE kx, ky, int; Variable nF		Variable angle	Variable pnt = numpnts(kx)		Duplicate/o kx kx_old, temp_kx	Duplicate/o ky ky_old, temp_ky	Duplicate/o int int_old		redimension/n=(pnt*nF) kx,ky,int	Variable index = 1	do		angle = 360/nF		temp_kx = kx_old		temp_ky = ky_old				rotate_2D(temp_kx,temp_ky,angle*index)				kx[index*pnt,(index+1)*pnt-1] = temp_kx[p-pnt*index]		ky[index*pnt,(index+1)*pnt-1] = temp_ky[p-pnt*index]				int[index*pnt,(index+1)*pnt-1] = int_old[p-pnt*index]			index += 1	while(index < nF)	KillWaves/Z kx_old, temp_kx, ky_old, temp_kyend// get a list of all names of waves of any dimension in the datafolder 'DF', including all its // subfolders.//	in_DF = highest datafolder, e.g. "root:"//	match = matchstring. If omitted, defaults to "*"//	dim = dimension of waves. If omitted, searches waves with all dimensions.//	fullPath. If 1, return full path to wave. if 0(default), only return wavename.Function/S utils_getWaveList(in_DF, [match, dim, fullPath])	String in_DF, match	Variable dim	Variable fullPath	if (ParamIsDefault(match))		match="*"	endif		String Df = getDataFolder (1)	if (!stringmatch(in_DF[strlen(in_DF)-1],":" ) )		in_DF += ":"	endif	SetDataFolder $in_DF		String listOfWaves = ""				Variable i = 0	for (i = 0; strlen(GetIndexedObjName(in_DF, 4, i)) != 0; i+=1)		String folderName = GetIndexedObjName(in_DF, 4, i)		if (is_liberal(folderName))			Abort "Sorry, you cannot use liberal DF-names with 'i_photo.'\rPlease rename the folder '"+folderName+"'!"		endif		String ret = utils_getWaveList(in_DF+foldername+":", match=match, dim=dim,fullPath=fullPath)		listOfWaves += ret	endfor	String dimStr = "DIMS:"+num2str(dim)	if (dim == 0)		dimStr = ""	endif	String wlist = WaveList(match, ";",dimStr)	for (i = 0; i < ItemsInList(wlist); i+=1)		if (fullPath)			listOfWaves += in_DF		endif		listOfWaves += StringFromList(i, wlist) + ";"	endfor	SetDataFolder $DF	return listOfWavesEndFunction utils_x0(w)	Wave w		return DimOffset(w, 0)EndFunction utils_x1(w)	Wave w		return DimOffset(w, 0) + (dimsize(w,0)-1) *DimDelta(w,0)EndFunction utils_y0(w)	Wave w		return DimOffset(w, 1)EndFunction utils_y1(w)	Wave w		return DimOffset(w, 1) + (dimsize(w,1)-1) *DimDelta(w,1)EndFunction utils_z0(w)	Wave w		return DimOffset(w, 2)EndFunction utils_z1(w)	Wave w		return DimOffset(w, 2) + (dimsize(w,2)-1) *DimDelta(w,2)EndFunction utils_pnt2x(w,p)	WAVE w	Variable p	return DimOffset(w, 0) + DimDelta(w, 0) * pEndFunction utils_pnt2y(w,p)	WAVE w	Variable p	return DimOffset(w, 1) + DimDelta(w, 1) * pEndFunction utils_pnt2z(w,p)	WAVE w	Variable p	return DimOffset(w, 2) + DimDelta(w, 2) * pEndFunction utils_x2pnt(w,x)	WAVE w	Variable x	return ( x - utils_x0(w) ) / DimDelta(w, 0)EndFunction utils_y2pnt(w,y)	WAVE w	Variable y	return ( y - utils_y0(w) ) / DimDelta(w, 1)EndFunction utils_z2pnt(w,z)	WAVE w	Variable z	return ( z - utils_z0(w) ) / DimDelta(w, 2)End// used in order to "paint" a line in a 2D wave w.// Sets a line of specified length to the specified value. This is a rather dumb algorithm// to draw a line, but it does not have to be that quick, and after all, it's better than// what Igor offers for that purpose, which is nothing.// Note that the units are in x, y, not in p, qFunction utils_drawLineInMatrix(w, x0, y0, x1, y1, value)	WAVE w	Variable x0, y0, x1, y1, value	Variable p0 = round(utils_x2pnt(w,x0))	Variable q0 = round(utils_y2pnt(w,y0))	Variable p1 = round(utils_x2pnt(w,x1))	Variable q1 = round(utils_y2pnt(w,y1))		Variable i	if (p1 < p0)		i = p0; p0 = p1; p1 = i		i = q0; q0 = q1; q1 = i	endif	Variable dq = (q1 - q0) / (p1 - p0)	Variable qq = q0	if (p1 - p0 == 0)		dq = q1 - q0	endif	for (i = p0; i <= p1; i += 1)		Variable py0 = round(min(qq,qq+dq))		Variable py1 = round(max(qq,qq+dq))		w[i][py0,py1] = value		qq += dq	endforEnd// This function takes the modulo of arg 1 wrt arg 2. i.e. in // c notation, the result would be: arg1 % arg2// this is here because... you guessed it: Igor is not even able // to implement a simple modulo operation right (!)// This is basically a CPU call, so you just need to forward the // mod operation to your CPU. I can by no means imagine how you can// screw that up. Maybe they add an idiot factor to it before they// hand it over to the CPU to make entirely sure that the result that// comes back is NOT correct? This is so rotten...// also, this function is positive-definite, i.e. all functions are// clamped to [0,arg2), and not (-arg2,arg2) which is what the Igor mod// does and which is - again - totally uselessFunction utils_mod(arg1, arg2)	Variable arg1, arg2	Variable ret = arg1 - trunc(arg1 / arg2) * arg2	return (ret < 0) ? arg2 + ret : retEnd// scales the dimension dim of wave w with factor.// Unlike just multiplying DimDelta, this function scales around the center // (i.e. the zero-point) of the data, or center, if given.Function utils_scaleDimSize(w, dim, factor, [center, centerIsInPoints])	WAVE w	Variable dim, factor, center, centerIsInPoints	Variable off = DimOffset(w, dim)	Variable delta = DimDelta(w, dim)	Variable size = DimSize(w, dim)	if (ParamIsDefault(center))		center = off/delta	endif	if (ParamIsDefault(centerIsInPoints))		centerIsInPoints = 1	endif	if (centerIsInPoints == 0)		center = ( center - DimOffset(w, dim) ) / DimDelta(w, dim)	endif	delta *= factor	off = center *delta	String dims = "x;y;z;t"	String cmd	sprintf cmd, "SetScale/P %s, %e, %e, %s", StringFromList(dim, dims), off, delta, NameOfWave(w)	Execute/Q cmdEnd// scales the dimension dim of wave w with factor.// Unlike just multiplying DimDelta, this function scales around the center // (i.e. the zero-point) of the data, or center, if given.Function utils_shiftDimSize(w, dim, offset)	WAVE w	Variable dim, offset	Variable off = DimOffset(w, dim)	Variable delta = DimDelta(w, dim)	Variable size = DimSize(w, dim)	off += offset	String dims = "x;y;z;t"	String cmd	sprintf cmd, "SetScale/P %s, %e, %e, %s", StringFromList(dim, dims), off, delta, NameOfWave(w)	Execute/Q cmdEnd// Fixes a dead pixel in a 2D wave w. pos is where the dead pixel is, in point scaling.Function utils_fixScientaDeadPixel(w, pos)	Variable pos	WAVE w	Make/O/N=(DimSize(w, 1)) w_tmp	w_tmp[] = w[pos-1][p]	Variable i0 = sum(w_tmp)	w_tmp[] = w[pos][p]	Variable i = sum(w_tmp)	w_tmp[] = w[pos+1][p]	Variable i1 = sum(w_tmp)	Variable n = (i1+i0)/2 / i	w[pos][] = w[pos][q] * n	KillWaves w_tmpEnd// trims a surface to be plotted by the NewGizmo.// Igor is too dumb to provide an easy way to cut off the data, i.e. manually // scale the axes.// Of course the surface plot uses the Gizmo and is too dumb to do it right as well.// w - the wave to be cut/trimmed.// trim - one of: "x0", "x1", "y0", "y1", "z0", "z1"// v - the value above which to cut//// Returns 1 if something was cut, 2 if the cut would empty the whole thing, and 0 if// no cut was made.Function utils_trimGizmoSurface(w, trim, v)	WAVE w	String trim	Variable v	Duplicate/O w, w_tmp	Variable retval = 0	strswitch(trim)		case "x0":			Variable pnt = utils_x2pnt(w, v)			if (pnt > 0 && pnt < DimSize(w, 0))				Redimension/N=(DimSize(w, 0)-pnt, DimSize(w,1)) w_tmp				w_tmp = w[p+pnt][q]				SetScale/P x, utils_pnt2x(w, pnt), DimDelta(w, 0), w_tmp				retval = 1			elseif(pnt <= 0)				retval = 0			else				retval = 2			endif			break		case "x1":			pnt = utils_x2pnt(w, v)			if (pnt > 0 && pnt < DimSize(w, 0))				Redimension/N=(pnt, DimSize(w,1)) w_tmp				w_tmp = w[p][q]				SetScale/P x, DimOffset(w, 0), DimDelta(w, 0), w_tmp				retval = 1			elseif (pnt >=DimSize(w, 0))				retval = 0			else				retval = 2			endif			break		case "y0":			pnt = utils_y2pnt(w, v)			if (pnt > 0 && pnt < DimSize(w, 1))				Redimension/N=(DimSize(w,0), DimSize(w, 1)-pnt) w_tmp				w_tmp = w[p][q+pnt]				SetScale/P y, utils_pnt2y(w, pnt), DimDelta(w, 1), w_tmp				retval = 1			elseif(pnt <= 0)				retval = 0			else				retval = 2			endif			break		case "y1":			pnt = utils_y2pnt(w, v)			if (pnt > 0 && pnt < DimSize(w, 1))				Redimension/N=(DimSize(w,0), pnt) w_tmp				w_tmp = w[p][q]				SetScale/P y, DimOffset(w, 1), DimDelta(w, 1), w_tmp				retval = 1			elseif (pnt >=DimSize(w, 1))				retval = 0			endif			retval = 2			break		case "z0":			Duplicate/O w_tmp, w_tmp2			Variable i, j			Variable isCutEntirely = 1			For (i = 0; i < DimSize(w_tmp, 0); i += 1)				For (j = 0; j < DimSize(w_tmp, 1); j += 1)					if (w_tmp[i][j] < v)						w_tmp2[i][j] = NaN						retval = 1					else						w_tmp2[i][j] = w_tmp[i][j]						isCutEntirely = 0					endif				EndFor			EndFor			if (isCutEntirely)				Duplicate/O w_tmp2, w_tmp				retval = 2			endif			break		case "z1":			Duplicate/O w_tmp, w_tmp2			isCutEntirely = 1			For (i = 0; i < DimSize(w_tmp, 0); i += 1)				For (j = 0; j < DimSize(w_tmp, 1); j += 1)					if (w_tmp[i][j] > v)						w_tmp2[i][j] = NaN						retval = 1					else						w_tmp2[i][j] = w_tmp[i][j]						isCutEntirely = 0					endif				EndFor			EndFor			if (isCutEntirely)				Duplicate/O w_tmp2, w_tmp				retval = 2			endif			break		default:			abort "trim mode not recognized."	endswitch	doupdate	WAVE w_tmp2	if (stringmatch(trim, "z*") && retval == 1)		w_tmp = w_tmp2[p][q]		For (i = 1; i < DimSize(w_tmp, 0) - 1; i += 1)			For (j = 1; j < DimSize(w_tmp, 1) - 1; j += 1)				Variable nn = 0				nn += (numtype(w_tmp2[i-1][j-1]) == 0)				nn += (numtype(w_tmp2[i-1][j]) == 0)				nn += (numtype(w_tmp2[i-1][j+1]) == 0)				nn += (numtype(w_tmp2[i][j-1]) == 0)				nn += (numtype(w_tmp2[i][j+1]) == 0)				nn += (numtype(w_tmp2[i+1][j-1]) == 0)				nn += (numtype(w_tmp2[i+1][j]) == 0)				nn += (numtype(w_tmp2[i+1][j+1]) == 0)				if (numtype(w_tmp2[i][j]) == 0)					w_tmp[i][j] = w_tmp2[i][j]				elseif (nn > 0)					Variable avg = 0					avg += (numtype(w_tmp2[i-1][j-1]) == 0) ? w_tmp2[i-1][j-1] : 0					avg += (numtype(w_tmp2[i-1][j]) == 0) ? w_tmp2[i-1][j] : 0					avg += (numtype(w_tmp2[i-1][j+1]) == 0) ? w_tmp2[i-1][j+1] : 0					avg += (numtype(w_tmp2[i][j-1]) == 0) ? w_tmp2[i][j-1] : 0					avg += (numtype(w_tmp2[i][j+1]) == 0) ? w_tmp2[i][j+1] : 0					avg += (numtype(w_tmp2[i+1][j-1]) == 0) ? w_tmp2[i+1][j-1] : 0					avg += (numtype(w_tmp2[i+1][j]) == 0) ? w_tmp2[i+1][j] : 0					avg += (numtype(w_tmp2[i+1][j+1]) == 0) ? w_tmp2[i+1][j+1] : 0					avg /= nn					if (abs(avg - v) < 0.1)						w_tmp[i][j] = v					endif				else					w_tmp[i][j] = NaN				endif			EndFor		EndFor	endif	Duplicate/O w_tmp, w//	KillWaves w_tmp, w_tmp2	return retvalEnd// Finds and generates peak positions it finds by taking the// second derivative of each trace it finds on the current graph,// between the two cursor positions.// THIS IS NOT FOOL PROOF:// - make sure you have a graph with traces and that both//   cursors are on the graph before you call this// - This will generate a LOT of waves in the directories of//   the waves that represent the traces on the graph. Make//   sure that all the traces are in a subdirectory.//// Generates waves with <wavename>_px and <wavename>_py// for each <wavename> found on the graph. These waves contain// the x and y positions of the peaks.// delta_e: in case the trace has an x and y wave, this is the // regular spacing distance of the x-direction that the y-wave// will be interpolated to before smoothing.// e-smoothing: the gaussian width by which the data will be // smoothed before taking the 2nd derivative. Playing with this// lets you determine how sensitive the peak finder is, e.g.// how much noise it will pick up, etc.// advanced: if set to 1, use advanced method for peak finding.// Usually yields better results, but you need to try this out from case to case// threshold: a threshold above which a peak is not disregardedFunction utils_gen2ndDeriv(e_smoothing, [threshold, delta_e, advanced])	Variable delta_e	Variable e_smoothing	Variable threshold	Variable advanced	if (ParamIsDefault(threshold))		threshold = -inf	endif		String traces = TraceNameList("", ";",1)	Variable i	for( i = 0; i < ItemsInList(traces,";"); i += 1 )		String ytrace = StringFromList(i, traces)		String xtrace = StringByKey("XWAVE", TraceInfo("", ytrace, 0) )		if (stringmatch(ytrace, "*_px") || stringmatch(ytrace, "*_py"))			continue		endif		WAVE w_y = TraceNameToWaveRef("", ytrace)		ytrace = GetWavesDataFolder(w_y,2)		Variable x1 = 0		Variable x2 = 0		if (strlen(xtrace)>0)			WAVE w_x = TraceNameToWaveRef("", xtrace)			xtrace = GetWavesDataFolder(w_x,2)			x2 = w_x[DimSize(w_x, 0)-1]		else			x2 = utils_x1(w_y)		endif		if (strlen(CsrInfo(A)) > 0 && strlen(CsrInfo(B)) > 0)			x1 = min(xcsr(A), xcsr(B))			x2 = max(xcsr(A), xcsr(B))		endif		printf "2nd deriv peaks in wave (%d of %d) %s in range %f to %f:\r\t", i, ItemsInList(traces, ";"), ytrace, x1, x2		String peaks_y = ytrace + "_py"		String peaks_x = ytrace + "_px"		Make/O/N=0 $peaks_x		WAVE w_peaks_x = $peaks_x		Make/O/N=0 $peaks_y		WAVE w_peaks_y = $peaks_y		Variable e_smoothing_p		if (strlen(xtrace)>0) // x wave supplied. -> We need to interpolate			if (ParamIsDefault(delta_e))				delta_e = DimSize(w_x, 0) / abs(w_x[0] - w_x[DimSize(w_x,0)-1])			endif			Variable n = trunc(abs(w_x[0] - w_x[DimSize(w_x,0)-1])/delta_e + 1)			Make/O/N=(n) w_gen2ndTmp			SetScale/P x, w_x[0], delta_e, w_gen2ndTmp			e_smoothing_p = e_smoothing/delta_e			Interpolate2/I=3/Y=w_gen2ndTmp w_x, w_y		else			Duplicate/O w_y, w_gen2ndTmp			e_smoothing_p = e_smoothing/DimDelta(w_y, 0)		endifDoUpdate		Duplicate/O w_gen2ndTmp, w_gen2ndDTmp		Smooth/B=1 (e_smoothing_p), w_gen2ndDTmpDoUpdate				if (advanced)			Differentiate w_gen2ndDTmp			Smooth/B=1 (e_smoothing_p), w_gen2ndDTmpDoUpdate			Differentiate w_gen2ndDTmp			Smooth/B=1 (e_smoothing_p), w_gen2ndDTmpDoUpdate		endif				Variable xp		for (xp = x1; xp < x2; xp += e_smoothing)			if (advanced == 0) //standard algorithm:				FindPeak/Q/M=(threshold)/R=(xp, x2) w_gen2ndDTmp				if (V_flag != 0)					break				endif			else // advanced algorithm:				FindPeak/Q/N/M=(-threshold)/R=(xp,x2) w_gen2ndDTmp				if (V_flag != 0)					break				endif			endif			xp = V_PeakLoc			Variable num = DimSize(w_peaks_x, 0)			Redimension/N=(num+1) w_peaks_x, w_peaks_y						w_peaks_x[num] = V_PeakLoc			w_peaks_y[num] = w_gen2ndTmp(V_PeakLoc)			printf "%f ", w_peaks_x[num]		endfor		printf "\r"	endfor//	KillWaves w_gen2ndTmp, w_gen2ndDTmpEnd// Removes the peaks generated by utils_gen2ndDeriv from the current// graph.Function utils_remove2ndDeriv()	String traces = TraceNameList("", ";",1)	Variable i	for( i = 0; i < ItemsInList(traces,";"); i += 1 )		String ytrace = StringFromList(i, traces)		String xtrace = StringByKey("XWAVE", TraceInfo("", ytrace, 0) )		if (stringmatch(ytrace, "*_px") || stringmatch(ytrace, "*_py"))			Execute/Z "RemoveFromGraph "+ytrace		endif	endforEnd// Adds peaks generated by utils_gen2ndDeriv to the current graph.// The peaks will have the same relative offsets as the graphs they belong// to, so doing this to MDC or EDC curves actually works :-)//// bar_len: length of the bar to be drawn at the peak. This is passed to // Igor's ErrorBars const= option.// bar_thick: thickness of the bars. Passed to ErrorBars/L=// bar_r, bar_g, bar_b: color of the peak bars. if set to negative values,// the color of the corresponding trace is used.Function utils_add2ndDeriv(bar_len, bar_thick, bar_r, bar_g, bar_b, [reorder])	Variable bar_len	Variable bar_thick	Variable bar_r	Variable bar_g	Variable bar_b	Variable reorder	if(ParamIsDefault(reorder))		reorder = 1	endif	utils_remove2ndDeriv()	DoUpdate	String traces = TraceNameList("", ";",1)	Variable i	for( i = 0; i < ItemsInList(traces,";"); i += 1 )		String ytrace = StringFromList(i, traces)		WAVE w_y = TraceNameToWaveRef("", ytrace)		String ytraceDF = GetWavesDataFolder(w_y,2)		String peaks_y = ytrace + "_py"		String peaks_x = ytrace + "_px"		String peaks_yDF = ytraceDF + "_py"		String peaks_xDF = ytraceDF + "_px"		String tmp = ListMatch(TraceInfo("",ytrace,0),"offset*",";")		tmp = ReplaceString(";", tmp, "")		String offset = tmp[strsearch(tmp, "=",0)+1,strlen(tmp)]		sprintf tmp, "AppendToGraph %s vs %s", peaks_yDF, peaks_xDF		Execute tmp		if(reorder == 1)			Execute/Q "ReorderTraces "+ytrace+", {"+ytrace+", "+peaks_y+"}"		endif		if (bar_r >= 0 & bar_g >= 0 & bar_b >= 0)			sprintf tmp, "ModifyGraph mode(%s)=2,rgb(%s)=(%d,%d,%d)", peaks_y, peaks_y, bar_r, bar_g, bar_b		else			tmp = ListMatch(TraceInfo("",ytrace,0),"rgb*",";")			tmp = ReplaceString(";", tmp, "")			String rgb = tmp[strsearch(tmp, "=",0)+1,strlen(tmp)]			sprintf tmp, "ModifyGraph mode(%s)=2,rgb(%s)=%s", peaks_y, peaks_y, rgb		endif		Execute tmp		sprintf tmp, "ModifyGraph offset(%s)=%s", peaks_y, offset		Execute tmp		sprintf tmp, "ErrorBars/T=0/L=%d %s Y,const=%e", bar_thick, peaks_y, bar_len		Execute tmp	endforEnd// Function prototype for utils_NewtonOpt. // This will always abort.Function utils_defaultOptFn(w_parm, x0, y0)	WAVE w_parm	Variable x0, y0	Abort "Please specify a valid optimization function."End// Does Newtonian optimization. Uses x0, y0 as the starting point.// This only works for bi-variate functions.// optFn needs to be a function like optFn(w_parm, x, y).// This function assumes that optFn returns a single value and that // at the optimum value of x0, y0, optFn(x0, y0) == 0. // Furthermore, optFn is assumed to be >= 0 always.//// So, this function is the most useful for numerically solving equations://     Imagine an equation f(x, y) == v, then write down an optFn like so://     Function optFn(w_parm, x, y)//          WAVE w_parm//          ... // do initialization etc. here//          return ( f(x, y) - v )^2//     End// If optFn(x0, y0) < tol, the function aborts and claims a minimum has been// found.//// h specifies the finite difference of the derivative, i.e. // df/dx = ( f(x+h/2, y) - f(x-h/2, y) ) / h// h should be large enough in order to avoid numerical errors due to finite// precision truncation and small enough in order for the iterations to be// stable enough to go below tol.//// g (optional) specifies the damping. The newtonian steps are defined// as:// x_n+1 = x_n + g * [H(f)]^-1 * grad(f)// where H is the hessian of f.// The default is 0.9//// maxSteps (optional) specifies the maximum steps after which the // optimization is assumed to have failed. In this case, the variables // holding the optimized value are set to NaN. // The default is 0, which means, this algorithm will never abort.//// VARIABLES:// V_minloc_x, V_minloc_y: hold the minimum x, y location.// V_OptNumIters: number of iterations performed.// V_min: minimum value of function.Function utils_NewtonOpt(optFn, w_parm, x0, y0, tol, h, [g, maxSteps, maxStepSize, neglectCrossTerm])	FUNCREF utils_defaultOptFn optFn	WAVE w_parm	Variable x0, y0, tol, h	Variable g, maxSteps, maxStepSize, neglectCrossTerm	if (ParamIsDefault(g))		g = 0.9	endif	if (ParamIsDefault(maxStepSize))		maxStepSize = 0	endif	if (ParamIsDefault(maxSteps))		maxSteps = 0	endif		Variable xn = x0	Variable yn = y0	Variable/G V_minloc_x = NaN, V_minloc_y = NaN	Variable/G V_OptNumIters = 0	Variable/G V_min	do		Variable f_x_y = optFn(w_parm, xn, yn)		Variable f_xph_y = optFn(w_parm, xn+h/2, yn)//		Variable f_xmh_y = optFn(w_parm, xn-h/2, yn)//		Variable f_x_yph = optFn(w_parm, xn, yn+h/2)//		Variable f_x_ymh = optFn(w_parm, xn, yn-h/2)//		Variable dfdx = ( f_xph_y - f_xmh_y ) / h		Variable dfdy = ( f_x_yph - f_x_ymh ) / h		Variable ddfddx = ( -2*f_x_y + f_xmh_y + f_xph_y ) / h^2 * 4		Variable ddfddy = ( -2*f_x_y + f_x_ymh + f_x_yph ) / h^2 * 4		Variable ddfdxdy		if (neglectCrossTerm)			ddfdxdy = 0		else			ddfdxdy = ( optFn(w_parm, xn+h/2, yn+h/2)-optFn(w_parm, xn+h/2, yn-h/2) - optFn(w_parm, xn-h/2, yn+h/2)+optFn(w_parm, xn-h/2, yn-h/2) ) / h^2		endif		Variable det = ddfddx*ddfddy - ddfdxdy^2		Variable dx = - g / det * (ddfddy*dfdx - ddfdxdy*dfdy)		Variable dy = - g / det * (-ddfdxdy*dfdx + ddfddx*dfdy)		Variable d = sqrt(dx^2 + dy^2)		if (maxStepSize > 0 && d > maxStepSize)			dx *= maxStepSize / d			dy *= maxStepSize / d		endif		xn += dx		yn += dy		V_min = optFn(w_parm, xn, yn)		V_OptNumIters += 1		if (maxSteps > 0 && V_OptNumIters > maxSteps)			return 0		EndIf	while(V_min > tol)	V_minloc_x = xn	V_minloc_y = yn	return 1EndFunction/S utils_wordWrap(str, maxlen, [respectWhitespaces])	String str	Variable maxlen	Variable respectWhitespaces	if(paramIsDefault(respectWhitespaces) == 1)		respectWhitespaces = 1	endif	Variable i	Variable c_a = char2num("a")	Variable c_AA = char2num("A")	Variable c_z = char2num("z")	Variable c_ZZ = char2num("Z")	Variable c_0 = char2num("0")	Variable c_9 = char2num("9")	Variable c__ = char2num("_")	for (i = 0; i < strlen(str)-maxlen;)		if (strsearch(str, "\r", i+maxlen, 1) > i)			i = strsearch(str, "\r",  i+maxlen, 1)			continue		endif		Variable idx = i + maxlen		if (respectWhitespaces == 1)			Variable j			for (j = i + maxlen; j >= i; j -= 1)				Variable c = char2num(str[j])				if ( (c >= c_a && c < c_z) || (c >= c_AA && c < c_ZZ) || (c >= c_0 && c < c_9) || c == c__)					continue				endif				break			endfor			if (j > i)				idx = j			endif		endif		str = str[0,idx] + "\r" + str[idx+1,strlen(str)]		i = idx + 1	endfor	return strEnd